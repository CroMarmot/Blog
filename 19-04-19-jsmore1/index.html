<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="googlea0cb77247135ae4c.html">

<link rel="stylesheet" href="/Blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cromarmot.github.io","root":"/Blog/","images":"/Blog/images","scheme":"Muse","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/Blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/Blog/js/config.js"></script>

    <meta name="description" content="笔记个人笔记！不是文档！大家 尽量减少个人文档行为，多做公共wiki和文档翻译！ 感谢https:&#x2F;&#x2F;zh.javascript.info https:&#x2F;&#x2F;javascript.info 有精力的朋友还是建议读上面链接,如果它们的文档有帮助，也建议购买它们的 epub&#x2F;pdf 作为支持 本文是基于我C++的熟练，和一定时间js使用后的阅读知识补充整理,章节分化基本和上面链接的内容对应 J">
<meta property="og:type" content="article">
<meta property="og:title" content="js 基础&amp;进阶 速查笔记">
<meta property="og:url" content="https://cromarmot.github.io/Blog/19-04-19-jsmore1/index.html">
<meta property="og:site_name" content="Cro-Marmot&#39;s Blog">
<meta property="og:description" content="笔记个人笔记！不是文档！大家 尽量减少个人文档行为，多做公共wiki和文档翻译！ 感谢https:&#x2F;&#x2F;zh.javascript.info https:&#x2F;&#x2F;javascript.info 有精力的朋友还是建议读上面链接,如果它们的文档有帮助，也建议购买它们的 epub&#x2F;pdf 作为支持 本文是基于我C++的熟练，和一定时间js使用后的阅读知识补充整理,章节分化基本和上面链接的内容对应 J">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://i.stack.imgur.com/UfXRZ.png">
<meta property="og:image" content="https://zh.javascript.info/task/class-extend-object/rabbit-extends-object@2x.png">
<meta property="og:image" content="https://zh.javascript.info/article/browser-environment/windowObjects.png">
<meta property="og:image" content="https://zh.javascript.info/article/dom-navigation/dom-links.png">
<meta property="og:image" content="https://zh.javascript.info/article/dom-navigation/dom-links-elements.png">
<meta property="og:image" content="https://zh.javascript.info/article/basic-dom-node-properties/dom-class-hierarchy.png">
<meta property="article:published_time" content="2019-04-19T03:20:14.000Z">
<meta property="article:modified_time" content="2023-05-09T19:11:37.032Z">
<meta property="article:author" content="Cro-Marmot">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.stack.imgur.com/UfXRZ.png">


<link rel="canonical" href="https://cromarmot.github.io/Blog/19-04-19-jsmore1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://cromarmot.github.io/Blog/19-04-19-jsmore1/","path":"19-04-19-jsmore1/","title":"js 基础&进阶 速查笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>js 基础&进阶 速查笔记 | Cro-Marmot's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/Blog/css/noscript.css">
  </noscript>
<link rel="alternate" href="/Blog/atom.xml" title="Cro-Marmot's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cro-Marmot's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li><li class="menu-item menu-item-archives"><a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔<span class="badge">127</span></a></li><li class="menu-item menu-item-yearmonth"><a href="/Blog/yearmonth/" rel="section"><i class="fa fa-calendar-days fa-fw"></i>年月</a></li><li class="menu-item menu-item-categories"><a href="/Blog/categories/" rel="section"><i class="fa fa-shapes fa-fw"></i>分類<span class="badge">34</span></a></li><li class="menu-item menu-item-tags"><a href="/Blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤<span class="badge">147</span></a></li><li class="menu-item menu-item-rss"><a href="/Blog/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>rss</a></li><li class="menu-item menu-item-about"><a href="/Blog/20-07-13-rsa/#contact" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0"><span class="nav-text">笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%84%9F%E8%B0%A2"><span class="nav-text">感谢</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2"><span class="nav-text">JavaScript 基础知识 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-2-15"><span class="nav-text">函数 2.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-vs-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E-2-16"><span class="nav-text">函数表达式 vs 函数声明 2.16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8F%B7"><span class="nav-text">分号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F-3"><span class="nav-text">代码质量 3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-3-5"><span class="nav-text">测试 3.5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Polyfill-3-6"><span class="nav-text">Polyfill 3.6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-%E6%94%AF%E6%8C%81"><span class="nav-text">ES6 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Babel"><span class="nav-text">Babel</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Objects%EF%BC%88%E5%AF%B9%E8%B1%A1%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-4"><span class="nav-text">Objects（对象）：基础知识 4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1-4-1"><span class="nav-text">对象 4.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-text">计算属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6in"><span class="nav-text">for…in</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6-%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8-4-2"><span class="nav-text">引用复制(值和引用) 4.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-4-3"><span class="nav-text">垃圾回收 4.3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let"><span class="nav-text">let</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol-%E7%B1%BB%E5%9E%8B-4-7"><span class="nav-text">Symbol 类型 4.7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8Ethis-4-4"><span class="nav-text">对象方法与this 4.4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-text">this运作方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84this"><span class="nav-text">箭头函数没有自己的this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2-4-8"><span class="nav-text">对象原始值转换 4.8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol-toPrimitive-String-Number"><span class="nav-text">Symbol.toPrimitive String Number</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol-toPrimitive"><span class="nav-text">Symbol.toPrimitive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string"><span class="nav-text">string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#number"><span class="nav-text">number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default-%E6%9C%AA%E7%9F%A5%E7%8A%B6%E5%86%B5"><span class="nav-text">default 未知状况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-number-%E4%BE%8B%E5%AD%90"><span class="nav-text">string+number 例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-text">运作方式总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6new"><span class="nav-text">构造函数和操作符new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-chaining-%E2%80%98-%E2%80%99-4-6"><span class="nav-text">Optional chaining ‘?.’ 4.6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5"><span class="nav-text">数据类型 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Advanced-working-with-functions-6"><span class="nav-text">Advanced working with functions 6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0-Rest-%E5%8F%82%E6%95%B0%E4%B8%8E-Spread-%E8%AF%AD%E6%B3%95-6-2"><span class="nav-text">任意长度参数  Rest 参数与 Spread 语法 6.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setTimeout-%E5%92%8C-setInterval"><span class="nav-text">setTimeout 和 setInterval</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-amp-bug-fix"><span class="nav-text">优化 &amp; bug fix</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF-7-amp-8"><span class="nav-text">对象、类和继承 7&amp;8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">函数原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mixin-%E6%A8%A1%E5%BC%8F-9-7"><span class="nav-text">Mixin 模式 9.7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8try%E2%80%A6catch%E2%80%A6finally-10-1"><span class="nav-text">异常try…catch…finally 10.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-10-2"><span class="nav-text">Error 10.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator-and-Promise"><span class="nav-text">Generator and Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Module-%E7%AE%80%E4%BB%8B"><span class="nav-text">Module 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy"><span class="nav-text">Proxy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%84%9F%E8%B0%A2-1"><span class="nav-text">感谢</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Document-1"><span class="nav-text">Document 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B-2"><span class="nav-text">事件简介 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UI%E4%BA%8B%E4%BB%B6-3"><span class="nav-text">UI事件 3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%EF%BC%8C%E6%8E%A7%E4%BB%B6-4"><span class="nav-text">表单，控件 4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E6%A1%A3%E5%92%8C%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-5"><span class="nav-text">加载文档和其他资源 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9-6"><span class="nav-text">杂项 6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MORE"><span class="nav-text">MORE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-x2F-MicroTask"><span class="nav-text">Task&#x2F;MicroTask</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cro-Marmot"
      src="https://avatars.githubusercontent.com/u/24691835?v=4">
  <p class="site-author-name" itemprop="name">Cro-Marmot</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/Blog/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/Blog/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/Blog/tags/">
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cromarmot" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cromarmot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yexiaorain@gmail.com" title="E-Mail → mailto:yexiaorain@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atcoder.jp/users/cromarmot" title="https:&#x2F;&#x2F;atcoder.jp&#x2F;users&#x2F;cromarmot" rel="noopener" target="_blank">AtCoder</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://codeforces.com/profile/Cro-Marmot" title="https:&#x2F;&#x2F;codeforces.com&#x2F;profile&#x2F;Cro-Marmot" rel="noopener" target="_blank">Codeforces</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-TW">
    <link itemprop="mainEntityOfPage" href="https://cromarmot.github.io/Blog/19-04-19-jsmore1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/24691835?v=4">
      <meta itemprop="name" content="Cro-Marmot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cro-Marmot's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="js 基础&进阶 速查笔记 | Cro-Marmot's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          js 基础&进阶 速查笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2019-04-19 11:20:14" itemprop="dateCreated datePublished" datetime="2019-04-19T11:20:14+08:00">2019-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-05-10 03:11:37" itemprop="dateModified" datetime="2023-05-10T03:11:37+08:00">2023-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Blog/categories/frontend/" itemprop="url" rel="index"><span itemprop="name">frontend</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Blog/19-04-19-jsmore1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="19-04-19-jsmore1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="文章字數">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">文章字數：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="所需閱讀時間">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">所需閱讀時間 &asymp;</span>
      <span>24 分鐘</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>个人笔记！不是文档！大家 尽量减少个人文档行为，多做公共wiki和文档翻译！</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/">https://zh.javascript.info</a></p>
<p><a target="_blank" rel="noopener" href="https://javascript.info/">https://javascript.info</a></p>
<p>有精力的朋友还是建议读上面链接,如果它们的文档有帮助，也建议购买它们的 epub&#x2F;pdf 作为支持</p>
<p>本文是基于我C++的熟练，和一定时间js使用后的阅读知识补充整理,章节分化基本和上面链接的内容对应</p>
<h1 id="JavaScript-基础知识-2"><a href="#JavaScript-基础知识-2" class="headerlink" title="JavaScript 基础知识 2"></a>JavaScript 基础知识 2</h1><h2 id="函数-2-15"><a href="#函数-2-15" class="headerlink" title="函数 2.15"></a>函数 2.15</h2><h3 id="函数表达式-vs-函数声明-2-16"><a href="#函数表达式-vs-函数声明-2-16" class="headerlink" title="函数表达式 vs 函数声明 2.16"></a>函数表达式 vs 函数声明 2.16</h3><p><code>function a()&#123;&#125;</code> vs <code>a = function()&#123;&#125;</code></p>
<p>当 JavaScript 准备运行脚本或代码块时，它首先在其中查找函数声明并创建函数。我们可以将其视为“初始化阶段”。</p>
<p>在处理完所有函数声明后，执行继续。</p>
<p>所以以下可以而正常运行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明还是有代码块的问题</p>
<span id="more"></span>


<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;There will be an error after this message&quot;)</span><br><span class="line"></span><br><span class="line">[1, 2].forEach(alert)</span><br></pre></td></tr></table></figure>

<p>上面会报错，因为编译器不确定加分号，导致</p>
<p><code>alert()[1,2].forEach()</code> , 其中1,2视作 逗号表达式返回2，也就是取<code>alert()</code>返回数组的第二个元素</p>
<h1 id="代码质量-3"><a href="#代码质量-3" class="headerlink" title="代码质量 3"></a>代码质量 3</h1><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/ninja-code">https://zh.javascript.info/ninja-code</a> 这一章吐槽真的有趣23333</p>
<h2 id="测试-3-5"><a href="#测试-3-5" class="headerlink" title="测试 3.5"></a>测试 3.5</h2><p>同时适用于浏览器端和服务器端!</p>
<p>Mocha —— 核心框架：提供了包括 describe 和 it 的通用型测试函数和运行测试的主函数。</p>
<p>Chai —— 提供很多断言支持的库。它可以用很多不同的断言。现在我们只需要用 assert.equal。<a target="_blank" rel="noopener" href="http://chaijs.com/api/assert/">Chai doc</a></p>
<p>Sinon —— 用于监视函数、模拟内置函数和其他函数的库，我们稍后会用到它。</p>
<p>补充，现在还有可选的jasmine和karma</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;pow&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;raises to n-th power&quot;, function() &#123;</span><br><span class="line">    assert.equal(pow(2, 3), 8);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个测试检测一个东西。</p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/testing-mocha">https://zh.javascript.info/testing-mocha</a> 上面的demo 有点长，但很好的，建议直接看网页</p>
<p><code>before/after and beforeEach/afterEach</code>测试前后包围</p>
<p>规范先行，实现在后。一个有良好测试的代码通常都有更好的架构。</p>
<p>测试规范，实际上 不应该在测试中 使用”运算“，否则可能需要 <strong>调试测试</strong></p>
<p>经过 具体化以后的测试，还可以使用<code>it()-&gt;it.only()</code>进行单个测试</p>
<h2 id="Polyfill-3-6"><a href="#Polyfill-3-6" class="headerlink" title="Polyfill 3.6"></a>Polyfill 3.6</h2><h3 id="ES6-支持"><a href="#ES6-支持" class="headerlink" title="ES6 支持"></a>ES6 支持</h3><p><a target="_blank" rel="noopener" href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a></p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>它将现代的 JavaScript 代码转化为上一代的标准形式。</p>
<p>脚本有一个术语 “polyfill” 表示用来“填补”缺口并添加缺少的实现。</p>
<p>两个有意思的 polyfills 是：</p>
<ul>
<li>babel polyfill 支持很多，但是很大。</li>
<li>polyfill.io 服务允许我们能根据自己所需的特性来按需加载、构建 polyfill。</li>
</ul>
<p>除了针对旧的版本，反过来，还有<a target="_blank" rel="noopener" href="https://www.google.com/chrome/canary/">https://www.google.com/chrome/canary/</a> 的为开发人员准备的未来版本，每日构建版本，不支持Linux？？？？？？ 操了</p>
<p><a target="_blank" rel="noopener" href="https://groups.google.com/a/chromium.org/forum/#!msg/chromium-discuss/GNE4pEXLMkQ/cis32ewLosYJ">https://groups.google.com/a/chromium.org/forum/#!msg/chromium-discuss/GNE4pEXLMkQ/cis32ewLosYJ</a></p>
<h1 id="Objects（对象）：基础知识-4"><a href="#Objects（对象）：基础知识-4" class="headerlink" title="Objects（对象）：基础知识 4"></a>Objects（对象）：基础知识 4</h1><h2 id="对象-4-1"><a href="#对象-4-1" class="headerlink" title="对象 4.1"></a>对象 4.1</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit+<span class="string">&#x27;2333&#x27;</span>]: <span class="number">5</span>, <span class="comment">// 属性名从 fruit 变量中计算 一般只有抽象出方法变量并且用于ide推断辅助时才用这个语法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特殊属性</p>
</blockquote>
<p><code>__proto__</code> 历史原因，不能设置为 非对象 值</p>
<blockquote>
<p>属性值简写(不建议)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">    age   <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><blockquote>
<p>和标题有点对不上，主要是 string和number转换相关</p>
</blockquote>
<p>字符串整数属性会相互转换,用加号控制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;Germany&quot;</span>, <span class="comment">//用加号 保护字符串不会被转化为数字</span></span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( +code ); <span class="comment">// 49, 41, 44, 1 // 这里感觉有问题，说是去加号，实际是转化成数值，但是如果值过大汇编成科学计数法，所以正确的应该还是字符串的去加号方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用复制-值和引用-4-2"><a href="#引用复制-值和引用-4-2" class="headerlink" title="引用复制(值和引用) 4.2"></a>引用复制(值和引用) 4.2</h2><p>原始类型是：字符串，数字，布尔类型 – 是被整个赋值的。</p>
<p>其它是引用</p>
<p>Object.assign 只是深度为1的深拷贝，要完全深拷贝，还是要自己实现,我喜欢在这里出面试题，深拷贝深比较</p>
<h2 id="垃圾回收-4-3"><a href="#垃圾回收-4-3" class="headerlink" title="垃圾回收 4.3"></a>垃圾回收 4.3</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>变量没有let就是全局</p>
<h2 id="Symbol-类型-4-7"><a href="#Symbol-类型-4-7" class="headerlink" title="Symbol 类型 4.7"></a>Symbol 类型 4.7</h2><p>对象的属性键只能是 String 类型或者 Symbol 类型。不是 Number，也不是 Boolean，只有 String 或 Symbol 这两种类型。</p>
<p>Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个不影响任何东西的标签。</p>
<p>Symbol 不能隐式的转换为String，要转化的话只能用 <code>toString()</code></p>
<p>Symbol 在 for…in 中被跳过</p>
<p>Symbol 在 Object.assign 中不会被忽略</p>
<p>全局注册表用法</p>
<p>let id &#x3D; Symbol.for(“id”)</p>
<p>返回key</p>
<p>Symbol.keyFor(Symbol.for(“test”))</p>
<p>从技术上说，Symbol 不是 100% 隐藏的。有一个内置方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 Symbol。还有一个名为 Reflect.ownKeys(obj) 返回所有键，包括 Symbol。所以它们不是真正的隐藏。但是大多数库、内置方法和语法结构都遵循一个共同的协议。而明确调用上述方法的人可能很清楚他在做什么。</p>
<p><a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-well-known-symbols">well known symbol</a></p>
<h2 id="对象方法与this-4-4"><a href="#对象方法与this-4-4" class="headerlink" title="对象方法与this 4.4"></a>对象方法与this 4.4</h2><h3 id="this运作方式"><a href="#this运作方式" class="headerlink" title="this运作方式"></a>this运作方式</h3><p>其实真的要讲就一句话，this在运行时才被复为具体的值，所以看运行到解释器去解释this那一行时的运行主体是谁即可。（这里忽略了一些编译器优化 可能发生的直观和实际造成的差异）</p>
<p>从根本上，我们是要去避免它带来的问题，而不是掌握它的各种用法。</p>
<p>怎样选择合适的实体？如何组织它们之间的交互？这就是架构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的代码没有语法错误：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// 严格模式(use strict)下是undefined，非严格模式下是window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用的是相同的函数</span></span><br><span class="line">user.<span class="property">f</span> = sayHi;</span><br><span class="line">admin.<span class="property">f</span> = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它们调用时有不同的 this 值。</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是点之前的这个对象。</span></span><br><span class="line">user.<span class="title function_">f</span>(); <span class="comment">// John  (this == user)</span></span><br><span class="line">admin.<span class="title function_">f</span>(); <span class="comment">// Admin  (this == admin)</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>

<p><code>this</code> 是在运行时求值的。它可以是任何值。在运行时对 this 求值的这个想法有其优缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性给错误留下了余地。这里我们的立场并不是要评判编程语言的这个想法的好坏，而是要了解怎样使用它，如何趋利避害。</p>
<p>要深入理解 obj.method() 调用的原理。</p>
<ol>
<li>首先，点 ‘.’ 取得这个 obj.method 属性。</li>
<li>其后的括号 () 调用它。</li>
</ol>
<p>错误示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="title function_">hi</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); &#125;,</span><br><span class="line">  <span class="title function_">bye</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="string">&quot;Bye&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">hi</span>(); <span class="comment">// John (the simple call works) 为了让 user.hi() 有效，JavaScript 用一个技巧 —— 这个 &#x27;.&#x27; 点返回的不是一个函数, 而是一种特殊的[引用类型]的值(https://tc39.github.io/ecma262/#sec-reference-specification-type).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们要判断 name 属性，来决定调用 user.hi 或是 user.bye。</span></span><br><span class="line">(user.<span class="property">name</span> == <span class="string">&quot;John&quot;</span> ? user.<span class="property">hi</span> : user.<span class="property">bye</span>)(); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>

<p>实际为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">XXX</span> = (user.<span class="property">name</span> == <span class="string">&quot;John&quot;</span> ? user.<span class="property">hi</span> : user.<span class="property">bye</span>);</span><br><span class="line"><span class="title function_">XXX</span>(); <span class="comment">// Error! 因为XXX没有this</span></span><br></pre></td></tr></table></figure>

<p>引用类型 <code>(base, name, strict)</code>三元组 ，其中<code>strict</code>为bool，与是否<code>use strict</code>相关</p>
<p>上面<code>user.hi()</code> (<code>user[&#39;hi&#39;]</code>同理)在严格模式下，对应<code>(user,&#39;hi&#39;,true)</code></p>
<p>而上面的<code>XXX = user.hi</code>过程中会丢掉user，只取函数,所以 一个<code>函数</code>，要么是一个单纯的函数，要没么是一个上面的三元组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user.<span class="title function_">hi</span>() <span class="comment">// 直接的调用</span></span><br><span class="line">(user.<span class="property">hi</span>)() <span class="comment">// 解析过程去括号 不算赋值，传递三元组引用</span></span><br><span class="line">(x=user.<span class="property">hi</span>)() <span class="comment">// 会在赋值时去掉user实体</span></span><br><span class="line">(<span class="number">1</span>==<span class="number">1</span>?user.<span class="property">hi</span>:alert)() <span class="comment">// 并没有看到 解析会自动简化</span></span><br><span class="line">(<span class="literal">true</span>?user.<span class="property">hi</span>:alert)() <span class="comment">// +1</span></span><br><span class="line">(user.<span class="property">hi</span> || alert)() <span class="comment">// +1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">ref1</span>: <span class="variable language_">this</span>, <span class="comment">// 会在上面的return的时候计算，这时候没有this ,所以 (a = makeUser())[&#x27;ref1&#x27;] 是undefined</span></span><br><span class="line">    <span class="attr">ref2</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 在执行时才计算 (a = makeUser())[&#x27;ref2&#x27;]() 得到本体</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 不会预先算</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数没有自己的this"><a href="#箭头函数没有自己的this" class="headerlink" title="箭头函数没有自己的this"></a>箭头函数没有自己的this</h3><p>箭头函数使用外部<code>正常的</code>函数的this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Ilya&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">firstName</span>);<span class="comment">// 替换为function()&#123;alert(this.firstName);&#125;后变为undefined</span></span><br><span class="line">    <span class="title function_">arrow</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure>

<h2 id="对象原始值转换-4-8"><a href="#对象原始值转换-4-8" class="headerlink" title="对象原始值转换 4.8"></a>对象原始值转换 4.8</h2><h3 id="Symbol-toPrimitive-String-Number"><a href="#Symbol-toPrimitive-String-Number" class="headerlink" title="Symbol.toPrimitive String Number"></a>Symbol.toPrimitive String Number</h3><blockquote>
<p>相对于c++ 的重载operator，</p>
</blockquote>
<h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>当一个对象被用在需要原始值的上下文中时，例如，在 alert 或数学运算中，它会使用 ToPrimitive 算法转换为原始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>])[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = <span class="keyword">function</span>(<span class="params">hint</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HINT[<span class="subst">$&#123;hint&#125;</span>]`</span>);&#125;</span><br><span class="line"><span class="title function_">alert</span>(x);</span><br></pre></td></tr></table></figure>

<p>从例子，首先能看到，是会调用到 该函数，第二能看到hint传递过来的是<code>string</code></p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>当一个操作期望一个字符串时，对于对象到字符串的转换</p>
<p><code>alert(obj)</code> 或<code>anotherObj[obj] = XXX;</code></p>
<p><code>toString -&gt; valueOf</code></p>
<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>当一个操作需要一个数字时，用于对象到数字的转换，如 maths</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title class_">Number</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// maths（除了二进制加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// 一元加法</span></span><br><span class="line"><span class="keyword">let</span> delta = date1 - date2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2;</span><br></pre></td></tr></table></figure>

<p><code>valueOf -&gt; toString</code></p>
<h4 id="default-未知状况"><a href="#default-未知状况" class="headerlink" title="default 未知状况"></a>default 未知状况</h4><p>例如 字符串+数字，是采用链接字符串，或数值相加，，这里说了一堆，大概意思是，default 可以视为和number 状况一致</p>
<h4 id="string-number-例子"><a href="#string-number-例子" class="headerlink" title="string+number 例子"></a>string+number 例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">money</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user); <span class="comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line"><span class="title function_">alert</span>(+user); <span class="comment">// valueOf -&gt; 1000</span></span><br><span class="line"><span class="title function_">alert</span>(user + <span class="number">500</span>); <span class="comment">// valueOf -&gt; 1500 假设valueOf不存在，则采用toString()</span></span><br></pre></td></tr></table></figure>

<h3 id="运作方式总结"><a href="#运作方式总结" class="headerlink" title="运作方式总结"></a>运作方式总结</h3><p>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</p>
<ol>
<li><p>调用 obj<a href="hint">Symbol.toPrimitive</a> 如果这个方法存在的话，</p>
</li>
<li><p>否则如果暗示是 “string”</p>
</li>
<li><p>尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。</p>
</li>
<li><p>否则，如果暗示 “number” 或者 “default”</p>
</li>
<li><p>尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。</p>
</li>
</ol>
<p>以上三个方法，不规定返回对应值，但一定要返回原始值[强制的]，[否则 有潜在递归可能性, 比如A.toString()返回类型A]</p>
<p>一点区别</p>
<p><code>toString/valueOf</code> 如果返回的不是原始值，则会被忽略该方法</p>
<p><code>Symbol.toPrimitive</code> 如果返回的不是原始值，则会报错被忽略该方法</p>
<h2 id="构造函数和操作符new"><a href="#构造函数和操作符new" class="headerlink" title="构造函数和操作符new"></a>构造函数和操作符new</h2><p>约定首字母大写…我们谈语法时别谈约定，可以说建议，如果代码一定要就eslint什么的搞一搞</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">user</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;; 隐方创建</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="comment">// return 2333; // 如果在过程中有return 会从这里停止，但是如果返回的是原始值(包括返回空),如这里的2333，则忽略这个值，返回this，如果返回值是object，则忽略this，返回object</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fuckable</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// return this; 隐式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个函数作为<code>new user(...)</code> (没有参数时，可以省略括号)执行时，它执行以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 this。</li>
<li>函数体执行。通常它会修改 this，为其添加新的属性。</li>
<li>返回 this 的值!!!</li>
</ol>
<p>单次使用<code>x = new function()&#123; ... &#125;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果你没有运行 new</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name); <span class="comment">// ...会为你添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john1 = <span class="title class_">User</span>(<span class="string">&quot;John1&quot;</span>); <span class="comment">// 重新调用 new User</span></span><br><span class="line"><span class="keyword">let</span> john2 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John2&quot;</span>); <span class="comment">// 正常的使用方法</span></span><br></pre></td></tr></table></figure>

<p><strong>但是不建议这样做，这样会对代码的阅读造成困扰</strong></p>
<h2 id="Optional-chaining-‘-’-4-6"><a href="#Optional-chaining-‘-’-4-6" class="headerlink" title="Optional chaining ‘?.’ 4.6"></a>Optional chaining ‘?.’ 4.6</h2><p>觊觎这个很久了，感觉还是历史遗留问题的 半 优化，没有从根本上解决问题。</p>
<p>虽然感觉根本办法还是应该在 和 其它端交互时进行 强制的状态和空值处理，TS基本考虑100%上，然后可以考虑用protobuf替代json。</p>
<h1 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型 5"></a>数据类型 5</h1><p>吐槽：看到<code>IE 浏览器不支持这个方法</code>就想笑</p>
<p>基本类型</p>
<ol>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (new in ECMAScript 6)</li>
</ol>
<p>基本类型在作为对象使用时，会临时创造一个包装对象，使用完后即销毁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a= <span class="number">3</span></span><br><span class="line">a.<span class="property">wasd</span>=<span class="function">()=&gt;</span><span class="number">233</span>; <span class="comment">//不会报错，因为a是基本类型，但是是放在上面说的临时对象上了</span></span><br><span class="line">a.<span class="title function_">wasd</span>();<span class="comment">// 报错 a.wasd不是function</span></span><br><span class="line">a.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// 基本类型 带有一些基本的方法</span></span><br></pre></td></tr></table></figure>

<p>哎 js还不支持<a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3499.html#SingleQuote">c++14支持的</a><code>a=1&#39;000&#39;000&#39;000</code>这种写法</p>
<p><code>toString(base)</code> 可以进行进制转换 <code>base</code> 取值<code>2-&gt;36</code></p>
<p>isNaN &#x2F; isFinite</p>
<p>之前看vuex源码时 ，看到很喜欢用new 来建立空的对象、数组什么的，难道是英文友好性，比如我一般写<code>a=[]</code>而他们可能就会写<code>a=new Array()</code></p>
<p>数组&#x3D;队列 支持 shift&#x2F;unshift (首部添加 慢)  和 pop&#x2F;push (尾部添加 较快)</p>
<p>数组引用的方式复制</p>
<p>遍历 <code>for i =0 -&gt; arr.length</code>, <code>for key in arr</code> (会迭代所有属性,这里说这还会慢..10-100倍 所以遍历数组通常不用forin), <code>for value of arr</code></p>
<p>性能测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">10000000</span>;i &lt; len; i++)&#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foriadd</span>(<span class="params">my_arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; my_arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    sum += my_arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forinadd</span>(<span class="params">my_arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> my_arr)&#123;</span><br><span class="line">    sum += my_arr[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forofadd</span>(<span class="params">my_arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> my_arr)&#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeTest</span>(<span class="params">func,my_arr,str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start_time = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="title function_">func</span>(my_arr);</span><br><span class="line">  <span class="keyword">let</span> end_time = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str,(end_time - start_time).<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">timeTest</span>(foriadd,arr,<span class="string">&#x27;foriadd&#x27;</span>); <span class="comment">// 17</span></span><br><span class="line"><span class="title function_">timeTest</span>(forinadd,arr,<span class="string">&#x27;forinadd&#x27;</span>); <span class="comment">// 3702 之所以慢 据说因为会引起和string之间的转换</span></span><br><span class="line"><span class="title function_">timeTest</span>(forofadd,arr,<span class="string">&#x27;forofadd&#x27;</span>); <span class="comment">// 150</span></span><br></pre></td></tr></table></figure>

<p>修改数组时，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。(慎用)</p>
<p>length 属性的另一个有意思的点是它是可写的。把它变小，数组真的可以变短，所以可以用arr.length&#x3D;0来清空..(为什么这里说这是清空数组的最好的方法？？？？？)…….. 危险的语言</p>
<p><strong>警告</strong> new Array(xxxx), 当xxxx是字符obj等东西的时候 实际创建的是 包含对应元素的数组，而是数字时，表示的是 对应长度的空数组</p>
<p>delete arr[1]; &#x2F;&#x2F; 如果arr的长度为5(大于2),会删除index&#x3D;&#x3D;1的元素，但是 不会把后面的向前移动，也不会影响length</p>
<p>arr.splice(index[,deleteCount,elem1,…,])</p>
<p><code>-1</code>的index 表示从尾部计算</p>
<p>还有支持简单参数的slice，</p>
<p>….说这么多 ，简单的说 数组别乱玩,</p>
<p>一些concat函数等就不说了，要用啥查啥</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort</span></span><br><span class="line">[<span class="number">1</span>, -<span class="number">2</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="comment">// 更建议箭头函数 ,返回正负零，不是true/false,类似c++ qsort接受的函数指针</span></span><br><span class="line">  <span class="title function_">alert</span>( a + <span class="string">&quot; &lt;&gt; &quot;</span> + b );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// reduce , previousValue — 是前一个函数调用的结果，第一次调用是初始化。</span></span><br><span class="line"><span class="keyword">let</span> value = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">previousValue, item, index, arr</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, initial);</span><br></pre></td></tr></table></figure>

<p>判断一个变量是否是数组，不要用typeof，用Array.isArray()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">find</span>(func, thisArg);</span><br><span class="line">arr.<span class="title function_">filter</span>(func, thisArg);</span><br><span class="line">arr.<span class="title function_">map</span>(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure>

<p>表示比较函数用的 2号参数，也就是 比较过程中采用<code>func(数组中的元素,thisArg);</code></p>
<p>可迭代对象(Iterables)</p>
<p>一个含有 [Symbol.iterator] key的对象，<a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable">实例</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="attr">x</span>:<span class="number">1</span>,y=<span class="number">2</span>&#125;;</span><br><span class="line">a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#123;<span class="attr">current</span>:<span class="variable language_">this</span>.<span class="property">x</span>,<span class="attr">last</span>:<span class="variable language_">this</span>.<span class="property">y</span>,<span class="title function_">next</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="variable language_">this</span>.<span class="property">current</span>&#125;; &#125;&#125;; &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>需要<code>Symbol.iterator</code></li>
<li>该函数返回值是个object (迭代器)，该object需要带有next()方法</li>
<li>next方法回传一个迭代器 <code>&#123;done:Boolean,value:any&#125;</code> 的形式，这样就可以支持，<code>for...of</code></li>
</ol>
<p>学过c++的就可以类比看看vector，string和它们的迭代器</p>
<p>Array.from(XXX) 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p>
<p>Map 可以用 对象作为key(区别于普通Object)………嗯嗯 好了好了  我知道了,说得c++好像不能用指针作为key一样</p>
<p>map的key比较是采用<code>===</code>, 然后map的set可以链式操作，因为返回本体</p>
<p><code>键值数组-&gt;new Map()-&gt;变为map</code></p>
<p><code>map/obj-&gt; Object.entries() -&gt; 变为键值数组</code> for..of会默认使用entries</p>
<p>js有Set, 迭代for..of 和 set.forEach</p>
<p>WeakMap&#x2F;WeakSet 忽略内存回收的依赖检测</p>
<p>这里说的适用场景，是有主对象控制区，在辅助非必要信息区域可以采用WeakMap来存</p>
<p>比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="title class_">WeakMap</span>.<span class="title function_">set</span>(obj,<span class="string">&quot;xxx&quot;</span>) <span class="comment">// obj位置的参数不能用原始类型</span></span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// obj 会被回收，也会从weakMap从消失，而如果把WeakMap换成Map，则因为，还能在map中找到不会被回收</span></span><br></pre></td></tr></table></figure>

<p><code>map.keys()</code> 返回的是迭代器不是 数组，用Array.from(map.keys())可以转化成数组</p>
<p>对于obj，Object.keys(obj)来返回<code>数组</code>，而不是迭代器</p>
<p>Object.keys&#x2F;values&#x2F;entries (), 忽略Symbol类型的属性</p>
<p>数组&#x2F;可迭代对象解构</p>
<p><code>let [a,b,c..] = arr/可迭代对象; // 自动分配到a,b,c</code></p>
<p><code>let [,,a,b,c..] = arr/可迭代对象; // 忽略前两个值</code></p>
<p><code>let [a,b,...rest] = arr/可迭代对象; // rest接受剩余元素</code></p>
<p>对象解构</p>
<p><code>let &#123;key1,key2&#125; = &#123;key1:...,key2:...&#125;</code> 以key配对，不是顺序</p>
<p><code>let &#123;key1:var1,key2:var2&#125; = &#123;key1:...,key2:...&#125;</code> 目标变量的写法</p>
<p><code>let &#123;key1= 100,key2:var2&#125; = &#123;key1:...,key2:...&#125;</code> 缺省值写法</p>
<p>严格模式下，先let后解构，外部加括号包起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>还有嵌套解构……..我觉得还行，感觉这也算得上半结构化了</p>
<p>然后函数传参可以用默认值+ 等于号的python里常看到的方法，假设有定义<code>f(x=1,y=3,z=4)&#123;&#125;</code>, 调用<code>f(z=233)</code></p>
<p>函数还可以写成 <code>f(&#123;a=1,b=7,c=3&#125;)&#123;&#125;</code>, 然后调用<code>x=&#123;b=2&#125;;f(x)</code></p>
<p>这一块来说就很是灵活好用易读的感觉了</p>
<p><code>date.get你希望改变的时间维度()+数值</code></p>
<p>Date.now()相当于 new Date().getTime(), 只会创建时间戳，性能友好 更快！</p>
<p>浏览器方法performance.now() 微秒数</p>
<p>JSON 相关，内部不应该有循环引用</p>
<p><code>JSON.stringify(value [,replacer(替换函数设置),space(空格缩进换行符设置) ])</code></p>
<p><code>JSON.stringify(value ,[指定属性1,指定属性2,...])</code></p>
<p>replacer : function(key,value) {return 替换值;}</p>
<p>toJson 函数可以重写，用于被解析</p>
<p>目前非标准的<a target="_blank" rel="noopener" href="https://json5.org/">https://json5.org/</a> 支持注释，无引号的键 !!</p>
<p><code>JSON.parse(data,function(key,value)&#123;return 定制化value;&#125;)，可以进行定制化处理</code></p>
<h1 id="Advanced-working-with-functions-6"><a href="#Advanced-working-with-functions-6" class="headerlink" title="Advanced working with functions 6"></a>Advanced working with functions 6</h1><h2 id="任意长度参数-Rest-参数与-Spread-语法-6-2"><a href="#任意长度参数-Rest-参数与-Spread-语法-6-2" class="headerlink" title="任意长度参数  Rest 参数与 Spread 语法 6.2"></a>任意长度参数  Rest 参数与 Spread 语法 6.2</h2><p><code>function f(...args)&#123;&#125;</code> &#x2F;&#x2F; 注意… 必须放在列表尾</p>
<p>或者通过内置的arguments访问(旧式的，这里没说不建议用)</p>
<p>箭头函数是没有 “arguments”,箭头函数内访问arguments等同于访问其外部非箭头函数的arguments</p>
<p>三点展开<code>a=[2,3,3]; f(...a);</code>&#x2F;&#x2F; 展开a并调用f,可以放在句中, 展开和for .. of 采用相同展开对象</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>变量环境</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                                                        <span class="comment">//     3</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;                                <span class="comment">//     3</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;                                        <span class="comment">//   2 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;                                   <span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> count++; <span class="comment">// has access to the outer counter  // 1 2 3</span></span><br><span class="line">  &#125;;                                                    <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;                                                       <span class="comment">//   2 3</span></span><br><span class="line">                                                        <span class="comment">//     3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">counter</span>() ); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">counter</span>() ); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">counter</span>() ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>JavaScript中的所有函数都是闭包</p>
<p>if for等的花括号内的 都有此法环境</p>
<p>在旧的脚本中，我们可以找到一个所谓的『立即调用函数表达式』（简称为 IIFE）用于此目的。</p>
<p><code>(function()&#123; /*.CODE HERE.*/; &#125;)()</code></p>
<p>除此以外还有方式</p>
<p><code>(function()&#123; /*.CODE HERE.*/; &#125;())</code></p>
<p><code>!function()&#123; /*.CODE HERE.*/; &#125;()</code></p>
<p><code>+function()&#123; /*.CODE HERE.*/; &#125;()</code></p>
<p>垃圾回收 与 闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 注释掉这一句查看变化</span></span><br><span class="line">    <span class="keyword">debugger</span>; <span class="comment">// 在控制台中输入 alert( value );没有该值！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [g,h];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [g,h] = <span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">g</span>();</span><br><span class="line"><span class="title function_">h</span>();</span><br></pre></td></tr></table></figure>

<p>通过上面的实验可以看到，</p>
<p>在有第一个console的时候，我们可以在debugger的位置访问到value，没有的这个console则则不行，也就是这里可以看到js预测下的优化，省略掉一些认为不存在的值,</p>
<p>因为我们的h在g函数之后，还能够访问value，但是g的位置在注释掉第一个console则访问不到，说明这个地方并不是value被回收了，而是，value没有被传入</p>
<p>用 var 声明的变量（不建议 不建议 不建议），不是函数范围就是全局的，它们在块内是可见的。也就是花括号 不会限制var， var 在函数开始时执行，不论声明位置，甚至是这样[所有函数内的var的声明 都会被提升到顶部，但是赋值的顺序不会变]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  phrase = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> phrase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">alert</span>(phrase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真的被使用了吗？如果你有疑问，可以去掉if以及var，你会发现在全局可以访问phrase，而加上if和var后，全局是访问不到phrase的，也就是说创建的是函数内的phrase，也就是var真的被执行了！！</p>
<p>在全局下使用let以后，这个变量也不是全局，只是”根”下可访问</p>
<p>全局的使用<code>window.XMLHttpRequest</code>检测类型，iframe 的正确窗口获取变量</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的<code>.name</code>能得到函数名<code>a =function()&#123;&#125;; b=&#123;c()&#123;&#125;&#125;; a.name;b.c.name;</code></p>
<p>而很多函数也没有函数名，<code>d=&#123;e:function()&#123;&#125;&#125;;d.e.name; l=b.c;</code>&#x2F;&#x2F; 最后这种赋值函数指针会带上函数名一起复制</p>
<p>函数的<code>.length</code>表示接受的参数个数,其中<code>...args</code>在计数中被忽略</p>
<p>函数可以加上属性XD有时用来代替闭包</p>
<p>如下的func秀啊</p>
<ol>
<li>它允许函数在内部引用自己。</li>
<li>它在函数外是不可见的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">func</span>(<span class="string">&quot;Guest&quot;</span>); <span class="comment">// 使用 func 再次调用自己 而不要使用sayHi，因为这里来说func不可变 sayHi是可变的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// Hello, Guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但这个无法生效</span></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure>

<p>嗯。。。。感觉这种就是个函数指针类似的玩法咯</p>
<p>可以还奶了一口jQuery和lodash</p>
<p>可以这样创建 函数，一下所有字段都是字符串 XD</p>
<p><code>let func = new Function ([arg1[, arg2[, ...argN]],] functionBody)</code></p>
<p>比如使用场景是，从服务器获取动态函数</p>
<p>但是new Function不论在哪里创建， 所指向的词法环境是全局，从一定程度上强迫写出好代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>); <span class="comment">// 基础语法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a,b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>); <span class="comment">// 逗号分隔</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a , b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>); <span class="comment">// 逗号和空格分隔</span></span><br></pre></td></tr></table></figure>

<h2 id="setTimeout-和-setInterval"><a href="#setTimeout-和-setInterval" class="headerlink" title="setTimeout 和 setInterval"></a>setTimeout 和 setInterval</h2><p>不在标准方法中不在规范中</p>
<p>取消调度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(...);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line"><span class="title function_">alert</span>(timerId);</span><br></pre></td></tr></table></figure>

<p>弹窗会让 Chrome&#x2F;Opera&#x2F;Safari 内的时钟停止!!!!!!???? 我的chromium 执行setInterval 如果不点，等一会，会连续冒出alert啊,难道chrome也改了？？</p>
<p>setTimeout(…,0) 尽快，但是在当前代码执行完后紧接着执行</p>
<p>这里有一种slot+setTimeout0分割任务CPU占用方法</p>
<p>用 setTimeout 进行分割和没用这两种做法在速度方面平分秋色，总的<code>计数过程</code>所花的时间几乎没什么差别。我一个总耗时2s，一个总耗时8s，但是我把它们都 用nodejs去跑的确时间差不多，也就是8s的应该在过程中处理了其它事件耗时了</p>
<p>HTML5 标准 所言：“经过 5 重嵌套之后，定时器运行间隔强制要求至少达到 4 毫秒”。服务端 JavaScript 就没这个限制了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">let</span> times = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">  times.<span class="title function_">push</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - start); <span class="comment">// 保存上次调用的延时</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start + <span class="number">100</span> &lt; <span class="title class_">Date</span>.<span class="title function_">now</span>()) <span class="title function_">alert</span>(times); <span class="comment">// 100 毫秒之后，显示延时信息</span></span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">setTimeout</span>(run, <span class="number">0</span>); <span class="comment">// 没超过 100 毫秒则再进行调度</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所有的调度方法都不能保证延时的准确性，所以在调度代码中，万不可依赖它。</p>
<h2 id="优化-amp-bug-fix"><a href="#优化-amp-bug-fix" class="headerlink" title="优化 &amp; bug fix"></a>优化 &amp; bug fix</h2><p>缓存包装函数，耗时久，但是输入输出稳定的，大量相同输入访问的函数的通用包装函数，见原文实现</p>
<p><code>func.call(context,...args)</code> 解决包装后上下文丢失没有this</p>
<p><code>func.apply(context,args)</code> 解决 多参数为一个数组</p>
<p><code>func(1,2,3) ≈ func.call(context,1,2,3) ≈ func.apply(context,[1,2,3])</code></p>
<p>&#x2F;&#x2F; 这里是外部再接受一个自定义hash函数来对多参数计算一个key,arguments本身不是数组，不过可以<code>[].join.call(arguments)</code>来拼接</p>
<p>下面几个装饰器 任务 挺有用</p>
<p>对于延迟的this丢失 处理</p>
<p><code>let newFunc = func.bind(thecontextyouwant)</code> 通过bind 指定this,只能bind一次，多次bind，第2次及以后的会被忽略</p>
<p><code>lodash 中的 _.bindAll(obj)。</code>批量绑定</p>
<p>另一种方案就是箭头函数了</p>
<p>偏函数,函数的封装&#x3D;.&#x3D; lodash 大法好啊 有对应的<code>_.partial</code></p>
<p>柯里化 把调用形式<code>f(a,b,c)</code>变为<code>f(a)(b)(c)</code>形式 lodash <code>_.curry</code> 用lodash的封装，柯里化之后 原来调用方法 依然正常运行：也可以柯里化格式调用</p>
<p>高级柯里化<code>https://github.com/lodash/lodash/blob/4.1.1-npm-packages/lodash.curry/index.js</code></p>
<h1 id="对象、类和继承-7-amp-8"><a href="#对象、类和继承-7-amp-8" class="headerlink" title="对象、类和继承 7&amp;8"></a>对象、类和继承 7&amp;8</h1><p>对象属性除<code>value</code>外还有三个特殊属性（所谓的“标志”）：</p>
<ol>
<li>writable — 如果为 true，则可以修改，否则它是只读的。</li>
<li>enumerable — 如果是 true，则可在循环中列出，否则不列出。for … in</li>
<li>configurable — 如果是 true，则此属性可以被删除，相应的特性也可以被修改，否则不可以。使属性不可配置是一条单行道。我们不能把它改回去.非严格模式 写入被忽略，严格模式报错</li>
</ol>
<p><code>Object.getOwnPropertyDescriptor(obj, propertyName);</code> 方法允许查询有关属性的完整信息。</p>
<p><code>Object.defineProperty(obj, propertyName, descriptor)</code> 可以修改标识</p>
<p>上面的两个方法均有带s的 多元素方法</p>
<p>如果用for..in复制对象，会忽略symbolic属性，这样可以 获取所有属性(“更好”的克隆)</p>
<p>还有一些属性(实践中不常用的) 见原文了</p>
<p><code>set v()&#123;return val;&#125;</code> &amp;&amp; <code>get v(val)&#123;return this.xxx=val;&#125;</code> 可以只有其中一个， 意味着只读或只写</p>
<p>属性可以是“数据属性”或“访问器属性”，但不能同时属于两者。</p>
<p>访问器没有value和writable属性，有的4个是</p>
<ol>
<li>get —— 一个没有参数的函数，在读取属性时工作，</li>
<li>set —— 带有一个参数的函数，当属性被设置时调用，</li>
<li>enumerable —— 与数据属性相同，</li>
<li>configurable —— 与数据属性相同。</li>
</ol>
<p>众所周知的协议，即以下划线<code>&quot;_&quot;</code>开头的属性是内部的，不应该从对象外部访问。eslint里没有 ，tslint有一种<code>member-access</code>的限制办法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br></pre></td></tr></table></figure>

<p>对象有一个特殊的隐藏属性 <code>Prototype</code> 值是null或是另一个引用对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">jumps</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.<span class="property">__proto__</span> = animal; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we can find both properties in rabbit now:</span></span><br><span class="line"><span class="title function_">alert</span>( rabbit.<span class="property">eats</span> ); <span class="comment">// true (**) 不存在属性 则从原型找，方法也是,原型也没有再一直向上直到找到或者遇到null</span></span><br><span class="line"><span class="title function_">alert</span>( rabbit.<span class="property">jumps</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不能通过子的修改原型的数据属性，只会对子实体增加键，</p>
<p>而原型上的getters&#x2F;setters，会运行，但是不论能找到的值在哪，只要解析this，始终是最初的子实体,也就是this不受到原型影响</p>
<p>意味着<code>A</code>有写方法<code>W</code>，会写<code>this.X</code>,<code>B</code>继承于<code>A</code>，那么<code>B</code>执行<code>W</code>会调用<code>A</code>的<code>W</code>，但是写的<code>this.x</code>会写到<code>B</code>上</p>
<p>按照c++的一些理解的话，是 他们之间有继承关系，所以执行函数会去找函数表，当子类没有时，就去父的表里找，找到执行时，传入的实体还是 子类</p>
<p>即使是这样，下面也列出了一个 <code>错误/危险</code>的实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hamster = &#123;</span><br><span class="line">  <span class="attr">stomach</span>: [],</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params">food</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stomach</span>.<span class="title function_">push</span>(food);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> speedy = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: hamster</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lazy = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: hamster</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This one found the food</span></span><br><span class="line">speedy.<span class="title function_">eat</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>( speedy.<span class="property">stomach</span> ); <span class="comment">// apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This one also has it, why? fix please.</span></span><br><span class="line"><span class="title function_">alert</span>( lazy.<span class="property">stomach</span> ); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure>

<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>设置 Rabbit.prototype &#x3D; animal 的这段代码表达的意思是：“当 new Rabbit 创建时，把它的 [[Prototype]] 赋值为 animal” 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认的 prototype</span></span><br><span class="line"><span class="comment">Rabbit.prototype = &#123; constructor: Rabbit &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Rabbit</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="comment">// 如果我们将整个默认原型替换掉，那么其中就不会有构造函数。</span></span><br><span class="line">  <span class="attr">jumps</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>();</span><br><span class="line"><span class="title function_">alert</span>(rabbit.<span class="property">constructor</span> === <span class="title class_">Rabbit</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以这个prototype，只是用于当一个 实例找不到对象key的时候，会去访问找个对象的原型(<code>.prototype</code>)的对应对象key，相当于用于记录的父类的一个属性，</p>
<p><code>__proto__</code>（实例上原型上都有，指向它的原型的<code>.prototype</code>）和<code>.prototype</code> (一般在原型上)的关系</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript">https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript</a></p>
<p><img data-src="https://i.stack.imgur.com/UfXRZ.png" alt="protovsprototype"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( <span class="keyword">new</span> <span class="title class_">Foo</span> ).<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">( <span class="keyword">new</span> <span class="title class_">Foo</span> ).<span class="property"><span class="keyword">prototype</span></span> === <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>Object.create(proto[, descriptors]) —— 利用 proto 作为 [[Prototype]] 和可选的属性描述来创建一个空对象。</li>
<li>Object.getPrototypeOf(obj) —— 返回 obj 对象的 [[Prototype]]。</li>
<li>Object.setPrototypeOf(obj, proto) —— 将 obj 对象的 [[Prototype]] 设置为 proto。</li>
</ol>
<p>潜在问题，如果我们的Object存的是用户提供的键值对，那么<code>__proto__</code>将会被忽略或其它错误，办法是使用Map，或者极简单的对象<code>let obj = Object.create(null)</code>，它的prototype是null,缺点则是没有默认的toString方法</p>
<p>属性描述器定义出来的是不可枚举的</p>
<p>ES6的class语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; <span class="comment">// 必须与new 关键字一起使用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125; <span class="comment">// 不需要逗号</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123; <span class="comment">// 静态方法 等同于写 User.staticMethod = ....</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span> === <span class="title class_">User</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p><code>super.</code>访问父类中的方法或些元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, earLength</span>) &#123; <span class="comment">// 会报错,在 JavaScript 中，“派生类的构造函数”与所有其他的构造函数之间存在区别。在派生类中，相应的构造函数会被标记为特殊的内部属性 [[ConstructorKind]]:&quot;derived&quot;。</span></span><br><span class="line">    <span class="comment">// 正确写法在这里调用 super(name)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">earLength</span> = earLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不生效！</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&quot;White Rabbit&quot;</span>, <span class="number">10</span>); <span class="comment">// Error: this is not defined.</span></span><br></pre></td></tr></table></figure>

<p>不同点就在于:</p>
<p>当一个普通构造函数执行时，它会创建一个空对象作为 this 并继续执行。</p>
<p>但是当派生的构造函数执行时，它并不会做这件事。它期望父类的构造函数来完成这项工作。</p>
<p>A 是基于 B, B 基于 C，</p>
<p>在调用时候this不变，不会在原型链上找所有,只会调用原型链上的第一个，所以如果写法都是this，可能导致无限递归</p>
<blockquote>
<p>[[HomeObject]] 特殊外部属性</p>
</blockquote>
<p>这个绑定是永久的，内置的，会绑定到父类。因此这是一个非常重要的语言变化。</p>
<p>只有调用<code>super.XXX</code>时才会被使用，所以不会破坏兼容性，解决上面this不会变导致无限循环的bug</p>
<p>在这种情况下，类中的 <code>func()&#123;&#125;</code>写法和<code>func:function()&#123;&#125;</code>写法就不同了，后面一种冒号的写法不会绑定<code>[[HomeObject]]</code></p>
<p>替换构造函数，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置函数会使用它作为构造函数</span></span><br><span class="line"><span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的例子很有价值看一看，<code>class X&#123;&#125;</code> vs <code>class X extends Object&#123;&#125;</code></p>
<ol>
<li>用了extends的派生类 必须调用super</li>
<li>用了extends相当于设置了<code>Rabbit.prototype.__proto__ = Object.prototype</code></li>
<li>用了extends相当于设置了<code>Rabbit.__proto__ = Object)</code>;</li>
</ol>
<p>如果没有<code>extends</code>的该处不会被设置,即无法访问静态方法<code>Rabibit.getOwnPropertyNames()</code>报错,其<code>.__proto__ = Function.prototype</code></p>
<p><img data-src="https://zh.javascript.info/task/class-extend-object/rabbit-extends-object@2x.png" alt="pic"></p>
<p><code>xxx instanceof 某类</code>检查一个变量实体是不是 属于一个类,改语法会在原型链上检测</p>
<p>该方法可以指定,设置 <code>static [Symbol.hasInstance](obj)&#123;&#125;</code>自定义检测方法</p>
<p>如果没有<code>[Symbol.hasInstance]</code>方法，那么实际的比较过程就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Class</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Class</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Class</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>实际的调用可以看做是<code>类.prototype.isPrototypeOf(obj)</code>,可以看做这个调用,所以如果<code>prototype</code>被修改，即使<code>__proto__</code>没被改，<code>rabbit instanceof Rabbit</code>会返回false</p>
<p>也可以用<code>toString</code>来做类型识别，<code>let arr=[];alert(arr.toString())</code>,或者</p>
<p><code>objectToString = Object.prototype.toString;alert(objectToString.call(arr))</code></p>
<p>对于自动以class，可以写<code>[Symbol.toStringTag]</code>字段来改变<code>toString()</code>的输出</p>
<p>这样的话 就比typeof更强大(支持自定义),甚至可以带上更多自定义信息，替代<code>instanceof</code></p>
<table>
<thead>
<tr>
<th></th>
<th>实例a</th>
<th>类名A</th>
<th>Function</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td><code>__proto__</code></td>
<td>等于它来源类的<code>prototype</code>,如果是Object.create(实例b)来的，则指向实例b</td>
<td><code>Object.__proto__</code> , 如果是 class extends B创建的 则等于<code>B</code></td>
<td>见下</td>
<td>见下</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>无</td>
<td>它自己的prototype,相反的方向Foo.prototype.constructor &#x3D;&#x3D;&#x3D; Foo</td>
<td>见下</td>
<td>Object的prototype</td>
</tr>
<tr>
<td><code>prototype.__proto__</code></td>
<td>无</td>
<td>Object.prototype</td>
<td>Object.prototype</td>
<td>null</td>
</tr>
</tbody></table>
<p><code>Function.__proto__ === Function.prototype === Object.__proto__ !== Object.prototype</code></p>
<table>
<thead>
<tr>
<th></th>
<th>用于</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>typeof</td>
<td>基本数据类型</td>
<td>string</td>
</tr>
<tr>
<td>{}.toString</td>
<td>基本数据类型、内置对象以及包含 Symbol.toStringTag 属性的对象</td>
<td>string</td>
</tr>
<tr>
<td>instanceof</td>
<td>任意对象</td>
<td>true&#x2F;false</td>
</tr>
</tbody></table>
<h3 id="Mixin-模式-9-7"><a href="#Mixin-模式-9-7" class="headerlink" title="Mixin 模式 9.7"></a>Mixin 模式 9.7</h3><p>单继承模式有时会对人进行限制，所以有了mixin，能同时实现支持多个类的方法实现</p>
<p>根据维基百科的定义，mixin 是一个包含许多供其它类使用的方法的类，而且这个类不必是其它类的父类。</p>
<p>换句话说，一个 mixin 提供了许多实现具体行为的方法，但是我们不单独使用它，我们用它来将这些行为添加到其它类中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;<span class="comment">// mixin自身内部可以使用继承</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Hello <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayBye</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Bye <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以说　hi 了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Dude&quot;</span>).<span class="title function_">sayHi</span>(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure>

<p><code>User.mixinfunction()</code>-&gt;首先通过User的prototype找到<code>User.prototype</code>,在调用<code>mixinfunction</code>时，因为mixin的类有自己的<code>[[HomeObject]]</code>所以如果有super，则会沿着<code>mixin</code>去找，而不是user</p>
<p>事件订阅mixin</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">   *  menu.on(&#x27;select&#x27;, function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_eventHandlers</span>) <span class="variable language_">this</span>.<span class="property">_eventHandlers</span> = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName].<span class="title function_">push</span>(handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">   *  menu.off(&#x27;select&#x27;, handler)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = <span class="variable language_">this</span>.<span class="property">_eventHandlers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName];</span><br><span class="line">    <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">        handlers.<span class="title function_">splice</span>(i--, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发事件并传递参数</span></span><br><span class="line"><span class="comment">   *  this.trigger(&#x27;select&#x27;, data1, data2);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">trigger</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_eventHandlers</span> || !<span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 对应事件名没有事件处理函数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用事件处理函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_eventHandlers</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> handler.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="异常try…catch…finally-10-1"><a href="#异常try…catch…finally-10-1" class="headerlink" title="异常try…catch…finally 10.1"></a>异常try…catch…finally 10.1</h3><p>catch到的</p>
<p>name -&gt; 异常名称</p>
<p>message -&gt; 详情描述</p>
<p>stack -&gt; 用于调试的</p>
<p>建议的:throw</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(message);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>catch 应该只捕获已知的异常，而重新抛出其他的异常。</p>
<p><code>try -&gt; catch -&gt; finally。</code>或者<code>try -&gt; finally</code></p>
<p>缺少catch时, <code>try-finally-&gt;throw err</code></p>
<blockquote>
<p>自定义错误</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message); <span class="comment">// (1)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;ValidationError&quot;</span>; <span class="comment">// (2)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ValidationError</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">property</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;PropertyRequiredError&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码越来越大，对于每个层次应该有专门的处理和转换</p>
<h2 id="Error-10-2"><a href="#Error-10-2" class="headerlink" title="Error 10.2"></a>Error 10.2</h2><p>其实是warning，但是写warning 可能没人看</p>
<p>现代的 JavaScript 引擎会做很多优化。相对于「正常情况」，它们可能会改变「人为测试」的结果，特别是我们度量的目标很细微。因此，如果你想好好了解一下性能，请学习 JavaScript 引擎的工作原理。在那之后，你可能再也不需要微度量了。</p>
<p>关于 V8 引擎的大量文章，点击：<a target="_blank" rel="noopener" href="http://mrale.ph/">http://mrale.ph</a>.</p>
<h2 id="Generator-and-Promise"><a href="#Generator-and-Promise" class="headerlink" title="Generator and Promise"></a>Generator and Promise</h2><p>我分别有写笔记</p>
<h2 id="Module-简介"><a href="#Module-简介" class="headerlink" title="Module 简介"></a>Module 简介</h2><p>AMD — 最古老的模块系统之一，最初由 require.js 库实现。</p>
<p>CommonJS — 为 Node.js 服务器创建的模块系统。</p>
<p>UMD — 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容</p>
<p><code>&lt;script type=&quot;module&quot;&gt;</code>和旧浏览器的nomodule</p>
<p>模块代码仅在第一次导入时被解析, 生成导出，然后它被分享给所有对其的导入，所以如果某个地方修改了 admin 对象，其他的模块也能看到这个修改。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h1 id="感谢-1"><a href="#感谢-1" class="headerlink" title="感谢"></a>感谢</h1><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/">https://zh.javascript.info</a></p>
<p>有精力的朋友还是建议读上面链接,如果它们的文档有帮助，也建议购买它们的 epub&#x2F;pdf 作为支持</p>
<p>本文是基于我C++的熟练，和一定时间js使用后的阅读知识补充整理,章节分化基本和上面链接的内容对应</p>
<p>该篇是对应上述链接的第二部分</p>
<h1 id="Document-1"><a href="#Document-1" class="headerlink" title="Document 1"></a>Document 1</h1><p>运行时 鸟瞰图</p>
<p><img data-src="https://zh.javascript.info/article/browser-environment/windowObjects.png" alt="鸟瞰图"></p>
<!-- more -->

<p>文档对象模型 DOM : document <a target="_blank" rel="noopener" href="https://dom.spec.whatwg.org/">https://dom.spec.whatwg.org/</a></p>
<p>开发人员必须为每个浏览器编写不同的代码。那是昏暗、混乱的时代。</p>
<p>现在尽管有两个组在做document，但它们99%是相似的</p>
<p>当我们修改文档的样式规则时，CSSOM 与 DOM 一起使用。但实际上，很少需要 CSSOM，因为通常 CSS 规则是静态的。 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/cssom-1/">https://www.w3.org/TR/cssom-1/</a></p>
<p>BOM(HTML规范的一部分):例如包括 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org</a></p>
<p>navigator,提供有关浏览器和操作系统的背景信息。</p>
<p>location允许读取和重定向URL</p>
<p>Mozilla 手册 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/search">https://developer.mozilla.org/en-US/search</a></p>
<p>DOM:</p>
<p><code>#text</code>永远是 DOM中的叶子节点</p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/dom-nodes">https://zh.javascript.info/dom-nodes</a></p>
<p>看这个举例，你会发现，比你预期的的#text会多更多,不过好在是这些都是#text，都是叶子节点，在过滤时只要规则正确，不会被过滤到</p>
<p>下面举例说如果你把各个<code>&lt;html&gt;</code>，<code>&lt;body&gt;</code>等之间的空格回车都去掉，那它们生成的dom树就不再会有多余的#text</p>
<p>开发者工具中的 DOM 结构已经过简化。文本节点仅以文本形式显。根本没有“空白”（只有空格）的文本节点</p>
<p>历史原因:</p>
<ol>
<li>由于历史原因，<code>&lt;head&gt;</code> 之前的空格和换行符被忽略，</li>
<li>如果我们在 <code>&lt;/body&gt;</code> 之后放置了一些东西，那么它会自动移动到 <code>body</code> 内部，因为 <code>HTML</code> 规范要求所有内容必须位于 <code>&lt;body&gt;</code> 内。所以 <code>&lt;/body&gt;</code> 后面可能没有空格。</li>
</ol>
<p>自动修正【看看，更多的还是应该保证 正确的编写</p>
<p>表格是一个有趣的“特例”。按照 <code>DOM</code> 规范，它们必须具有 <code>&lt;tbody&gt;</code>，但 <code>HTML</code> 文本可能（官方的）忽略它。然后浏览器自动在 <code>DOM</code> 中创建 <code>&lt;tbody&gt;</code>。</p>
<p>有12个节点类型，常用的就是你F12能看到的<code>document</code>，元素节点，文本节点,和注释</p>
<p><a target="_blank" rel="noopener" href="http://software.hixie.ch/utilities/js/live-dom-viewer/">http://software.hixie.ch/utilities/js/live-dom-viewer/</a></p>
<blockquote>
<p>以前也没系统的看过chrome的控制台方法 官方文档 TODO: <a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a></p>
</blockquote>
<p>现在最后选中的元素可以用 $0 来进行操作，以前选择的是 $1，如此等等。</p>
<p>我们可以在它们之上运行命令。例如，$0.style.background &#x3D; ‘red’ 使选定的列表项变成红色，</p>
<p>inspect(node)来从命令行，反过去找document中的元素</p>
<p>DOM 结构</p>
<p><img data-src="https://zh.javascript.info/article/dom-navigation/dom-links.png" alt="DOM"></p>
<p><code>document.body</code>,<code>document.head</code></p>
<p>在DOM中用<code>===null</code>判断节点不存在</p>
<p><code>childNodes</code>一个类似数组的个迭代集合只读,引用(实时的), <code>===.firstChild</code>, <code>===.lastChild</code>,<code>.hasChildNodes()</code></p>
<p><code>.previousSibling</code>,<code>.nextSibling</code></p>
<p>如果希望忽略文本和注释节点，只访问元素节点</p>
<p><img data-src="https://zh.javascript.info/article/dom-navigation/dom-links-elements.png" alt="DOM"></p>
<p>table支持更多的东西[感觉这部分主要是了解，因为 实际编写中，现在主流框架，基本很少需要进行原生元素的操作了[github说没用任何框架除外</p>
<p><code>.getElementsBy*</code>:<code>Id</code>,<code>TagName</code>,<code>Name</code>,<code>ClassName</code></p>
<p><code>.querySelectorAll()</code> ,<code>querySelector</code>,<code>.matches</code>,<code>.closest</code>(最近祖先匹配) 都是css相关的调用 方法 </p>
<p><strong>注意</strong>！ <code>getElementsBy*</code>返回的是 一个实时会变动的集合，而<code>querySelectorAll</code>返回的是一个<code>static</code>的</p>
<p>场景:</p>
<ol>
<li><p>获取元素</p>
</li>
<li><p>改变元素</p>
</li>
<li><p>操作元素 [如果用的<code>querySelectorAll</code>得到的，那么可能和当前真是的元素不一致]</p>
</li>
</ol>
<p>原文上给了几个操作的一个总结表[感觉因为现在基本都是框架就不整理进来了]</p>
<p><img data-src="https://zh.javascript.info/article/basic-dom-node-properties/dom-class-hierarchy.png" alt="DOM节点类"></p>
<p><a target="_blank" rel="noopener" href="https://dom.spec.whatwg.org/#interface-node">Node</a></p>
<p><code>Node</code> 是实现了DOM树上的节点方法，父，子，前后节点等</p>
<p><code>Element</code> 是DOM元素的基类,在Node之上，提供了<code>.*Element.*</code>,<code>query*</code></p>
<p><code>.nodeType == </code> 检查，是不是,元素节点，文本节点，document对象</p>
<p><code>.nodeName</code>(Node定义) 和<code>.tagName</code>(Element的节点) 总是全大写</p>
<p><code>.innerHTML</code>字符串html,<code>.outerHTML</code> , 相对于<code>.innerHTML</code>会多一层外层的包裹,注意到这些都是指针式的操作，所以outerHTML改完以后，不应该继续使用</p>
<p><code>.data</code>可以获取<code>.nodeValue/data</code>文本节点内容</p>
<p><code>.textContent</code>纯文本 [安全的！也就是不担心元素注入]</p>
<p><code>.hidden</code>是否可见 等同于<code>display:none;</code></p>
<p>除此以外，特例</p>
<p><code>input</code>,<code>select</code>,<code>textarea</code>都有<code>.value</code></p>
<p><code>a</code>有<code>href</code></p>
<p><code>id</code></p>
<h1 id="事件简介-2"><a href="#事件简介-2" class="headerlink" title="事件简介 2"></a>事件简介 2</h1><h1 id="UI事件-3"><a href="#UI事件-3" class="headerlink" title="UI事件 3"></a>UI事件 3</h1><h1 id="表单，控件-4"><a href="#表单，控件-4" class="headerlink" title="表单，控件 4"></a>表单，控件 4</h1><h1 id="加载文档和其他资源-5"><a href="#加载文档和其他资源-5" class="headerlink" title="加载文档和其他资源 5"></a>加载文档和其他资源 5</h1><h1 id="杂项-6"><a href="#杂项-6" class="headerlink" title="杂项 6"></a>杂项 6</h1><hr>
<h1 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h1><h2 id="Task-x2F-MicroTask"><a href="#Task-x2F-MicroTask" class="headerlink" title="Task&#x2F;MicroTask"></a>Task&#x2F;MicroTask</h2><p><a target="_blank" rel="noopener" href="https://javascript.info/event-loop">https://javascript.info/event-loop</a></p>
<p>同步</p>
<p>Task: script标签加载完，一个用户事件如Click,一个setTimeout</p>
<p>MicroTask: MutationObserver callbacks,例如promise的callback 或 await以后</p>
<p>看规范 <a target="_blank" rel="noopener" href="https://tc39.es/ecma262/#sec-jobs">https://tc39.es/ecma262/#sec-jobs</a></p>
<p>Host environments are not required to treat Jobs uniformly with respect to scheduling. For example, web browsers and Node.js treat Promise-handling Jobs as a higher priority than other work; future features may add Jobs that are not treated at such a high priority.</p>
<p>其实只严格FIFO</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>作者： </strong>Cro-Marmot
  </li>
  <li class="post-copyright-link">
      <strong>文章連結：</strong>
      <a href="https://cromarmot.github.io/Blog/19-04-19-jsmore1/" title="js 基础&amp;进阶 速查笔记">https://cromarmot.github.io/Blog/19-04-19-jsmore1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 許可協議。轉載請註明出處！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/Blog/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Blog/19-04-09-snap/" rel="prev" title="snap">
                  <i class="fa fa-chevron-left"></i> snap
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Blog/19-04-12-principles/" rel="next" title="原则">
                  原则 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cro-Marmot</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="總字數">693k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="所需總閱讀時間">10:30</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/Blog/js/comments.js"></script><script src="/Blog/js/utils.js"></script><script src="/Blog/js/schemes/muse.js"></script><script src="/Blog/js/next-boot.js"></script><script src="/Blog/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/Blog/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/Blog/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.2.0/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://cromarmot.github.io/Blog/19-04-19-jsmore1/"}</script>
  <script src="/Blog/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"cromarmot","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/Blog/js/third-party/comments/disqus.js"></script>

</body>
</html>
