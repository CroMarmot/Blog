<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="googlea0cb77247135ae4c.html">

<link rel="stylesheet" href="/Blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cromarmot.github.io","root":"/Blog/","images":"/Blog/images","scheme":"Muse","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/Blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/Blog/js/config.js"></script>

    <meta name="description" content="19-07-12  -&gt; 19-08-15  Hell world开始 &amp; 安装curl https:&#x2F;&#x2F;sh.rustup.rs -sSf | sh 网络真的是僵硬，下载下一年， 我用远端服务器就很快下了 真是艹了,我在远端 都跟着教程看了两章+尝试demo了，本地的build下载还没下好 国内的话 配置~&#x2F;.cargo&#x2F;config如下会稍微快一些,吐槽 1234567[reg">
<meta property="og:type" content="article">
<meta property="og:title" content="rust book 学习笔记">
<meta property="og:url" content="https://cromarmot.github.io/Blog/19-08-15-rust/index.html">
<meta property="og:site_name" content="Cro-Marmot&#39;s Blog">
<meta property="og:description" content="19-07-12  -&gt; 19-08-15  Hell world开始 &amp; 安装curl https:&#x2F;&#x2F;sh.rustup.rs -sSf | sh 网络真的是僵硬，下载下一年， 我用远端服务器就很快下了 真是艹了,我在远端 都跟着教程看了两章+尝试demo了，本地的build下载还没下好 国内的话 配置~&#x2F;.cargo&#x2F;config如下会稍微快一些,吐槽 1234567[reg">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl04-01.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl04-02.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl04-04.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl04-05.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl04-06.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl15-01.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl15-02.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl15-03.svg">
<meta property="og:image" content="https://doc.rust-lang.org/book/img/trpl15-04.svg">
<meta property="article:published_time" content="2019-08-15T07:09:01.000Z">
<meta property="article:modified_time" content="2022-08-16T02:31:28.094Z">
<meta property="article:author" content="Cro-Marmot">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://doc.rust-lang.org/book/img/trpl04-01.svg">


<link rel="canonical" href="https://cromarmot.github.io/Blog/19-08-15-rust/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://cromarmot.github.io/Blog/19-08-15-rust/","path":"19-08-15-rust/","title":"rust book 学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>rust book 学习笔记 | Cro-Marmot's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/Blog/css/noscript.css">
  </noscript>
<link rel="alternate" href="/Blog/atom.xml" title="Cro-Marmot's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cro-Marmot's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li><li class="menu-item menu-item-archives"><a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔<span class="badge">114</span></a></li><li class="menu-item menu-item-rss"><a href="/Blog/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>rss</a></li><li class="menu-item menu-item-categories"><a href="/Blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類<span class="badge">34</span></a></li><li class="menu-item menu-item-tags"><a href="/Blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤<span class="badge">124</span></a></li><li class="menu-item menu-item-about"><a href="/Blog/20-07-13-rsa/#contact" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Hell-world"><span class="nav-number">1.</span> <span class="nav-text">Hell world</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B-amp-%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.</span> <span class="nav-text">开始 &amp; 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IDE-x2F-vim%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.</span> <span class="nav-text">IDE&#x2F;vim配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">入门命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.</span> <span class="nav-text">依赖相关</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E5%86%99%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%B5%8B%E6%95%B0%E6%B8%B8%E6%88%8F"><span class="nav-number">2.</span> <span class="nav-text">基本语法+写一个猜测数游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8C%9C%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">猜数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#immutable%E5%92%8Cmutable"><span class="nav-number">2.2.</span> <span class="nav-text">immutable和mutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#match"><span class="nav-number">2.3.</span> <span class="nav-text">match</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">明确的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tuple-amp-array"><span class="nav-number">2.7.</span> <span class="nav-text">tuple &amp; array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">2.9.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.10.</span> <span class="nav-text">循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ownership-amp-slice"><span class="nav-number">3.</span> <span class="nav-text">Ownership &amp; slice</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#slice"><span class="nav-number">3.1.</span> <span class="nav-text">slice</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Struct"><span class="nav-number">4.</span> <span class="nav-text">Struct</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Enums-and-Option-and-Pattern-Matching"><span class="nav-number">5.</span> <span class="nav-text">Enums and Option and Pattern Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Managing-Growing-Projects-with-Packages-Crates-and-Modules"><span class="nav-number">6.</span> <span class="nav-text">Managing Growing Projects with Packages, Crates, and Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Packages-amp-Crates"><span class="nav-number">6.1.</span> <span class="nav-text">Packages &amp; Crates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Modules-to-Control-Scope-and-Privacy"><span class="nav-number">6.2.</span> <span class="nav-text">Defining Modules to Control Scope and Privacy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Path"><span class="nav-number">6.3.</span> <span class="nav-text">Path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#use"><span class="nav-number">6.4.</span> <span class="nav-text">use</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pub-use"><span class="nav-number">6.5.</span> <span class="nav-text">pub use</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package-%E5%BC%95%E5%85%A5"><span class="nav-number">6.6.</span> <span class="nav-text">package 引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E5%8C%96"><span class="nav-number">6.7.</span> <span class="nav-text">模块分化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Common-Collections"><span class="nav-number">7.</span> <span class="nav-text">Common Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vectors"><span class="nav-number">7.1.</span> <span class="nav-text">Vectors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Storing-UTF-8-Encoded-Text-with-Strings"><span class="nav-number">7.2.</span> <span class="nav-text">Storing UTF-8 Encoded Text with Strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Storing-Keys-with-Associated-Values-in-Hash-Maps"><span class="nav-number">7.3.</span> <span class="nav-text">Storing Keys with Associated Values in Hash Maps</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Error-Handling"><span class="nav-number">8.</span> <span class="nav-text">Error Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AFwith-panic"><span class="nav-number">8.1.</span> <span class="nav-text">不可恢复的错误with panic!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recoverable-Errors-with-Result"><span class="nav-number">8.2.</span> <span class="nav-text">Recoverable Errors with Result</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#To-panic-or-Not-to-panic"><span class="nav-number">8.3.</span> <span class="nav-text">To panic! or Not to panic!</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Generic-Types-Traits-and-Lifetimes"><span class="nav-number">9.</span> <span class="nav-text">Generic Types, Traits, and Lifetimes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Generic-Data-Types"><span class="nav-number">9.1.</span> <span class="nav-text">Generic Data Types</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">9.1.1.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits-Defining-Shared-Behavior"><span class="nav-number">9.2.</span> <span class="nav-text">Traits: Defining Shared Behavior</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8Atrait%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">9.2.1.</span> <span class="nav-text">把trait作为参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Validating-References-with-Lifetimes"><span class="nav-number">9.3.</span> <span class="nav-text">Validating References with Lifetimes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="nav-number">9.3.1.</span> <span class="nav-text">生命周期注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thinking-in-Terms-of-Lifetimes-%E4%BB%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83"><span class="nav-number">9.3.2.</span> <span class="nav-text">Thinking in Terms of Lifetimes 从生命周期的角度思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lifetime-Annotations-in-Method-Definitions"><span class="nav-number">9.3.3.</span> <span class="nav-text">Lifetime Annotations in Method Definitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Static-Lifetime"><span class="nav-number">9.3.4.</span> <span class="nav-text">The Static Lifetime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generic-Type-Parameters-Trait-Bounds-and-Lifetimes-Together"><span class="nav-number">9.3.5.</span> <span class="nav-text">Generic Type Parameters, Trait Bounds, and Lifetimes Together</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Writing-Automated-Tests"><span class="nav-number">10.</span> <span class="nav-text">Writing Automated Tests</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-Write-Tests"><span class="nav-number">10.1.</span> <span class="nav-text">How to Write Tests</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Controlling-How-Tests-Are-Run"><span class="nav-number">10.2.</span> <span class="nav-text">Controlling How Tests Are Run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Test-Organization"><span class="nav-number">10.3.</span> <span class="nav-text">Test Organization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unit-Tests"><span class="nav-number">10.3.1.</span> <span class="nav-text">Unit Tests</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integration-Tests"><span class="nav-number">10.3.2.</span> <span class="nav-text">Integration Tests</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integration-Tests-for-Binary-Crates"><span class="nav-number">10.3.2.1.</span> <span class="nav-text">Integration Tests for Binary Crates</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#An-I-x2F-O-Project-Building-a-Command-Line-Program"><span class="nav-number">11.</span> <span class="nav-text">An I&#x2F;O Project: Building a Command Line Program</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">接受命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reading-a-File"><span class="nav-number">11.2.</span> <span class="nav-text">Reading a File</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactoring-to-Improve-Modularity-and-Error-Handling"><span class="nav-number">11.3.</span> <span class="nav-text">Refactoring to Improve Modularity and Error Handling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Developing-the-Library%E2%80%99s-Functionality-with-Test-Driven-Development"><span class="nav-number">11.4.</span> <span class="nav-text">Developing the Library’s Functionality with Test-Driven Development</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Working-with-Environment-Variables"><span class="nav-number">11.5.</span> <span class="nav-text">Working with Environment Variables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Writing-Error-Messages-to-Standard-Error-Instead-of-Standard-Output"><span class="nav-number">11.6.</span> <span class="nav-text">Writing Error Messages to Standard Error Instead of Standard Output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BETDD"><span class="nav-number">11.7.</span> <span class="nav-text">回顾TDD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Functional-Language-Features-Iterators-and-Closures"><span class="nav-number">12.</span> <span class="nav-text">Functional Language Features: Iterators and Closures</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Closures-Anonymous-Functions-that-Can-Capture-Their-Environment"><span class="nav-number">12.1.</span> <span class="nav-text">Closures: Anonymous Functions that Can Capture Their Environment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Processing-a-Series-of-Items-with-Iterators"><span class="nav-number">12.2.</span> <span class="nav-text">Processing a Series of Items with Iterators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Improving-Our-I-x2F-O-Project"><span class="nav-number">12.3.</span> <span class="nav-text">Improving Our I&#x2F;O Project</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparing-Performance-Loops-vs-Iterators"><span class="nav-number">12.4.</span> <span class="nav-text">Comparing Performance: Loops vs. Iterators</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#More-About-Cargo-and-Crates-io"><span class="nav-number">13.</span> <span class="nav-text">More About Cargo and Crates.io</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Customizing-Builds-with-Release-Profiles"><span class="nav-number">13.1.</span> <span class="nav-text">Customizing Builds with Release Profiles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Publishing-a-Crate-to-Crates-io"><span class="nav-number">13.2.</span> <span class="nav-text">Publishing a Crate to Crates.io</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cargo-Workspaces"><span class="nav-number">13.3.</span> <span class="nav-text">Cargo Workspaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Installing-Binaries-from-Crates-io-with-cargo-install"><span class="nav-number">13.4.</span> <span class="nav-text">Installing Binaries from Crates.io with cargo install</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extending-Cargo-with-Custom-Commands"><span class="nav-number">13.5.</span> <span class="nav-text">Extending Cargo with Custom Commands</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Smart-Pointers"><span class="nav-number">14.</span> <span class="nav-text">Smart Pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Box-to-Point-to-Data-on-the-Heap"><span class="nav-number">14.1.</span> <span class="nav-text">Using Box to Point to Data on the Heap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait"><span class="nav-number">14.2.</span> <span class="nav-text">Treating Smart Pointers Like Regular References with the Deref Trait</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicit-Deref-Coercions-with-Functions-and-Methods"><span class="nav-number">14.2.1.</span> <span class="nav-text">Implicit Deref Coercions with Functions and Methods</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Running-Code-on-Cleanup-with-the-Drop-Trait"><span class="nav-number">14.3.</span> <span class="nav-text">Running Code on Cleanup with the Drop Trait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rc-the-Reference-Counted-Smart-Pointer"><span class="nav-number">14.4.</span> <span class="nav-text">Rc, the Reference Counted Smart Pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RefCell-and-the-Interior-Mutability-Pattern"><span class="nav-number">14.5.</span> <span class="nav-text">RefCell and the Interior Mutability Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-Cycles-Can-Leak-Memory"><span class="nav-number">14.6.</span> <span class="nav-text">Reference Cycles Can Leak Memory</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fearless-Concurrency"><span class="nav-number">15.</span> <span class="nav-text">Fearless Concurrency</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Threads-to-Run-Code-Simultaneously"><span class="nav-number">15.1.</span> <span class="nav-text">Using Threads to Run Code Simultaneously</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Message-Passing-to-Transfer-Data-Between-Threads"><span class="nav-number">15.2.</span> <span class="nav-text">Using Message Passing to Transfer Data Between Threads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-State-Concurrency"><span class="nav-number">15.3.</span> <span class="nav-text">Shared-State Concurrency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extensible-Concurrency-with-the-Sync-and-Send-Traits"><span class="nav-number">15.4.</span> <span class="nav-text">Extensible Concurrency with the Sync and Send Traits</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-Send-and-Sync-Manually-Is-Unsafe"><span class="nav-number">15.4.1.</span> <span class="nav-text">Implementing Send and Sync Manually Is Unsafe</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-Oriented-Programming-Features-of-Rust"><span class="nav-number">16.</span> <span class="nav-text">Object Oriented Programming Features of Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Characteristics-of-Object-Oriented-Languages"><span class="nav-number">16.1.</span> <span class="nav-text">Characteristics of Object-Oriented Languages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Trait-Objects-That-Allow-for-Values-of-Different-Types"><span class="nav-number">16.2.</span> <span class="nav-text">Using Trait Objects That Allow for Values of Different Types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-an-Object-Oriented-Design-Pattern"><span class="nav-number">16.3.</span> <span class="nav-text">Implementing an Object-Oriented Design Pattern</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Patterns-and-Matching"><span class="nav-number">17.</span> <span class="nav-text">Patterns and Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#All-the-Places-Patterns-Can-Be-Used"><span class="nav-number">17.1.</span> <span class="nav-text">All the Places Patterns Can Be Used</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refutability-Whether-a-Pattern-Might-Fail-to-Match"><span class="nav-number">17.2.</span> <span class="nav-text">Refutability: Whether a Pattern Might Fail to Match</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pattern-Syntax"><span class="nav-number">17.3.</span> <span class="nav-text">Pattern Syntax</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Advanced-Features"><span class="nav-number">18.</span> <span class="nav-text">Advanced Features</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsafe-Rust"><span class="nav-number">18.1.</span> <span class="nav-text">Unsafe Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dereferencing-a-Raw-Pointer"><span class="nav-number">18.1.1.</span> <span class="nav-text">Dereferencing a Raw Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calling-an-Unsafe-Function-or-Method"><span class="nav-number">18.1.2.</span> <span class="nav-text">Calling an Unsafe Function or Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-or-Modifying-a-Mutable-Static-Variable"><span class="nav-number">18.1.3.</span> <span class="nav-text">Accessing or Modifying a Mutable Static Variable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-an-Unsafe-Trait"><span class="nav-number">18.1.4.</span> <span class="nav-text">Implementing an Unsafe Trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">18.1.5.</span> <span class="nav-text">何时使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Traits"><span class="nav-number">18.2.</span> <span class="nav-text">Advanced Traits</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types"><span class="nav-number">18.2.1.</span> <span class="nav-text">Specifying Placeholder Types in Trait Definitions with Associated Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Default-Generic-Type-Parameters-and-Operator-Overloading"><span class="nav-number">18.2.2.</span> <span class="nav-text">Default Generic Type Parameters and Operator Overloading</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fully-Qualified-Syntax-for-Disambiguation-Calling-Methods-with-the-Same-Name"><span class="nav-number">18.2.3.</span> <span class="nav-text">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types"><span class="nav-number">18.2.4.</span> <span class="nav-text">Using the Newtype Pattern to Implement External Traits on External Types</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Types"><span class="nav-number">18.3.</span> <span class="nav-text">Advanced Types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Functions-and-Closures"><span class="nav-number">18.4.</span> <span class="nav-text">Advanced Functions and Closures</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Macros"><span class="nav-number">18.5.</span> <span class="nav-text">Macros</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute-like-macros"><span class="nav-number">18.5.1.</span> <span class="nav-text">Attribute-like macros</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-like-macros"><span class="nav-number">18.5.2.</span> <span class="nav-text">Function-like macros</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Final-Project-Building-a-Multithreaded-Web-Server"><span class="nav-number">19.</span> <span class="nav-text">Final Project: Building a Multithreaded Web Server</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Appendix"><span class="nav-number">20.</span> <span class="nav-text">Appendix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">21.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO"><span class="nav-number">22.</span> <span class="nav-text">TODO</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cro-Marmot"
      src="https://avatars.githubusercontent.com/u/24691835?v=4">
  <p class="site-author-name" itemprop="name">Cro-Marmot</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/Blog/archives/">
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/Blog/categories/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/Blog/tags/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cromarmot" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cromarmot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yexiaorain@gmail.com" title="E-Mail → mailto:yexiaorain@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atcoder.jp/users/cromarmot" title="https:&#x2F;&#x2F;atcoder.jp&#x2F;users&#x2F;cromarmot" rel="noopener" target="_blank">AtCoder</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://codeforces.com/profile/Cro-Marmot" title="https:&#x2F;&#x2F;codeforces.com&#x2F;profile&#x2F;Cro-Marmot" rel="noopener" target="_blank">Codeforces</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-TW">
    <link itemprop="mainEntityOfPage" href="https://cromarmot.github.io/Blog/19-08-15-rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/24691835?v=4">
      <meta itemprop="name" content="Cro-Marmot">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cro-Marmot's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="rust book 学习笔记 | Cro-Marmot's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rust book 学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2019-08-15 15:09:01" itemprop="dateCreated datePublished" datetime="2019-08-15T15:09:01+08:00">2019-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-08-16 10:31:28" itemprop="dateModified" datetime="2022-08-16T10:31:28+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Blog/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Blog/categories/code/backend/" itemprop="url" rel="index"><span itemprop="name">backend</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Blog/categories/code/backend/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Blog/19-08-15-rust/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="19-08-15-rust/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="文章字數">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">文章字數：</span>
      <span>113k</span>
    </span>
    <span class="post-meta-item" title="所需閱讀時間">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">所需閱讀時間 &asymp;</span>
      <span>1:42</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>19-07-12  -&gt; 19-08-15</p>
</blockquote>
<h1 id="Hell-world"><a href="#Hell-world" class="headerlink" title="Hell world"></a>Hell world</h1><h2 id="开始-amp-安装"><a href="#开始-amp-安装" class="headerlink" title="开始 &amp; 安装"></a>开始 &amp; 安装</h2><p><code>curl https://sh.rustup.rs -sSf | sh</code></p>
<p>网络真的是僵硬，下载下一年， 我用远端服务器就很快下了 真是艹了,我在远端 都跟着教程看了两章+尝试demo了，本地的build下载还没下好</p>
<p>国内的话 配置<code>~/.cargo/config</code>如下会稍微快一些,<a target="_blank" rel="noopener" href="https://twitter.com/gaocedidi/status/1158558939530706944?s=20">吐槽</a></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[registry]</span></span><br><span class="line"><span class="attr">index</span> = <span class="string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/&quot;</span></span><br><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">&#x27;ustc&#x27;</span></span><br><span class="line"><span class="section">[source.sjtug]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>更新</strong> 上面不能用的话看这里 <a target="_blank" rel="noopener" href="https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates">https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates</a></p>
<h2 id="IDE-x2F-vim配置"><a href="#IDE-x2F-vim配置" class="headerlink" title="IDE&#x2F;vim配置"></a>IDE&#x2F;vim配置</h2><p>我是用的<code>vim</code> + <code>spf13-vim</code>上加自己配置的 <code>~/.vimrc.local</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function CompileByFileType()</span><br><span class="line">  if &amp;filetype == &quot;cpp&quot;</span><br><span class="line">    &quot;!clang++ -o &quot;%&lt;&quot; &quot;%&quot; -std=gnu++17 -O2 -g -Wall -Wcomma</span><br><span class="line">    !clang++ -o &quot;%&lt;&quot; &quot;%&quot; -std=gnu++17 -g -Wall -Wcomma</span><br><span class="line">    &quot;!g++ -o &quot;%&lt;&quot; &quot;%&quot; -std=gnu++14 -O2 -g -Wall</span><br><span class="line">  elseif &amp;filetype == &quot;c&quot;</span><br><span class="line">    !gcc -o &quot;%&lt;&quot; &quot;%&quot; -O2 -g</span><br><span class="line">  elseif &amp;filetype == &quot;python&quot;</span><br><span class="line">    !python3 &quot;%&quot;</span><br><span class="line">  elseif &amp;filetype == &quot;go&quot;</span><br><span class="line">    !go run &quot;%&quot;</span><br><span class="line"><span class="addition">+  elseif &amp;filetype == &quot;rust&quot;</span></span><br><span class="line"><span class="addition">+    !cargo run</span></span><br><span class="line">  else</span><br><span class="line">    echo &quot;UNKNOWN FILETYPE : &amp;filetype&quot;</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">nnoremap &lt;F9&gt; :call CompileByFileType() &lt;CR&gt;</span><br></pre></td></tr></table></figure>

<p>其它的话 据说<code>Clion</code> + <code>rust插件</code> 不错</p>
<h2 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h2><p><code>rustup docs --book</code></p>
<p><del>66666 题外话，我觉得现代的游戏 除了游戏本身还需要 背景，目标玩家定位，目标游戏类型定位，以及自身完备性和营销。自身完备性比如观战，历史记录等，去年出的 刀牌 从6万峰值到现在上线就是世界前100,我认为其中缺少的就是完备性。而rust 带一个 这个文档66666</del></p>
<p>有了教程，那我yyp一点 教程里的总结吧</p>
<ul>
<li>单个rs:<code>rustc main.rs</code></li>
<li>build project using <code>cargo build</code> or <code>cargo check</code>.</li>
<li>build + run a project <code>cargo run</code>.</li>
<li>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the <code>target/debug</code> directory.</li>
<li>cargo build –release</li>
</ul>
<h2 id="依赖相关"><a href="#依赖相关" class="headerlink" title="依赖相关"></a>依赖相关</h2><p><del>如果玩过npm可以感觉到和package.json 和对应的lock相似</del></p>
<p>首先<code>Cargo.toml</code> 中加入需要依赖的库和版本描述，如<code>rand = &quot;0.3.14&quot;</code>,会匹配能匹配的某个版本</p>
<p>然后<code>cargo build</code></p>
<p><code>Cargo.lock</code>会保存首次build的各个库的版本</p>
<p>如果希望升级<code>cargo update</code></p>
<h1 id="基本语法-写一个猜测数游戏"><a href="#基本语法-写一个猜测数游戏" class="headerlink" title="基本语法+写一个猜测数游戏"></a>基本语法+写一个猜测数游戏</h1><h2 id="猜数"><a href="#猜数" class="headerlink" title="猜数"></a>猜数</h2><p>依赖</p>
<span id="more"></span>

<p>在<code>Cargo.toml</code>添加</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.3.14&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="immutable和mutable"><a href="#immutable和mutable" class="headerlink" title="immutable和mutable"></a>immutable和mutable</h2><p><code>default variables are immutable</code> ： 默认的变量是不变的 &#x3D;。&#x3D;????</p>
<p>和<code>const</code>的区别 <code>const</code> 的值只能由<code>const</code>表达式提供，所以可以看作 <code>immutable</code>是那种 从宏观上看是会变的，例如函数的入参，但对于函数内部可能是不变的?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x : <span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure>

<p>shadow掉。。。。。。。。。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// let 不能省略</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> 表达式/值 &#123;</span><br><span class="line">  值<span class="number">1</span> =&gt; 表达式/&#123;表达式,...&#125;,</span><br><span class="line">  值<span class="number">2</span> =&gt; ...,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="明确的类型"><a href="#明确的类型" class="headerlink" title="明确的类型"></a>明确的类型</h2><p><code>let guess = &quot;42&quot;.parse().expect(&quot;...&quot;)</code></p>
<p>没有指定<code>guess</code>的类型，而<code>parse</code>是有不同类型的方法，正确的办法<code>let guess: u32</code></p>
<p>基础类型: 浮点数 整数 布尔 字符(Rust’s <code>char</code> type is four bytes in size and represents a Unicode Scalar Value,比<code>ASCII</code>的<code>char</code>定义多 )</p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>进制直接描述法</p>
<table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>98_222</td>
</tr>
<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>
<tr>
<td>八进制</td>
<td>0o77</td>
</tr>
<tr>
<td>二进制</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (u8 only)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<p>在Debug模式下，overflow会<code>panic</code>，在release模式下， 会把overflow wrap掉</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>默认<code>f64</code>,可选 <code>f32</code></p>
<h2 id="tuple-amp-array"><a href="#tuple-amp-array" class="headerlink" title="tuple &amp; array"></a>tuple &amp; array</h2><p>Tuple</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500.6</span>.<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x,y,z) = tup;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">firstvalue</span> = tup.<span class="number">0</span>; <span class="comment">// 有点意思啊，c++的话 我印象中是 get&lt;index&gt;(某个tuple)</span></span><br></pre></td></tr></table></figure>

<p>Array 定长同类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>数组越界会报错 <code>:-)</code></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>let</code> 语句没有返回 所以不能写<code>let x= (let y =6)</code>这种代码</p>
<p>括号是一个表达式可以写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<span class="comment">// 输出4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数定义法<code>fn 函数名(参数1:类型,参数2:类型) -&gt; 返回类型 &#123;...&#125;</code></p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c++不同 ,rust的类型要求，不能<code>非零</code>和<code>零</code>，一定要<code>布尔</code></p>
<p>有趣的是 花括号时表达式 所以三元运算 可以写成<code>x = if true &#123; 2 &#125; else &#123; 3 &#125;</code></p>
<p>但是 返回类型如果有不同类型<code> let number = if condition &#123; 5 &#125; else &#123; &quot;six&quot; &#125;</code> 会报错</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">  <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">returnvaluefromloop</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span> the value you want <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">  <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">11</span>,<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ownership-amp-slice"><a href="#Ownership-amp-slice" class="headerlink" title="Ownership &amp; slice"></a>Ownership &amp; slice</h1><p>这使<code>rust</code>不需要<code>gc</code> 让内存安全得以保证，这一章讲<code>ownership</code>工作</p>
<p>对于内存使用，某些语言用<code>gc</code>，某些语言需要用户自己明确的管理，<code>rust</code>使用memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.所以对运行时速度不会有影响</p>
<p>这也是让<code>rust</code>独特的关键之一</p>
<p>介绍了一下 数据结构意义上的 栈和堆</p>
<p>Ownership rules</p>
<ol>
<li>每一个<code>value</code> 都有一个对应的变量是它的<code>owner</code></li>
<li>同一个时间点 只会有一个<code>owner</code></li>
<li>当<code>owner</code>出了对应的<code>scope</code>，值会被弃用</li>
</ol>
<p>变量的有效有两个关键的 时间点，入和出</p>
<ul>
<li>When s comes into scope, it is valid.</li>
<li>It remains valid until it goes out of scope.</li>
</ul>
<p>字面量string和 String::from的不同是，一个硬编码，一个运行时，如果按c++反编译回来理解，的话，有的<code>char</code>数组直接放在栈上，有的是一个公用地址放的字符，而<code>String</code>就是用多少是啥样了</p>
<p>rust通过 takes a different path: the memory is automatically returned once the variable that owns it goes out of scope</p>
<p>类似于 C++中的Resource Acquisition Is Initalization (RAII)</p>
<p><code>String</code>: <code>let s1 = String::from(&quot;hello&quot;);</code></p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="string"></p>
<p>然后<code>String</code>赋值 可以看做指针赋值大概</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="string"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>

<p>以上代码会报错</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="string move"></p>
<p>正确的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure>

<p>然后 原始类型都是默认<code>copy</code>如 <code>int</code></p>
<p>除此以Tuples, if they only contain types that are also Copy. For example, <code>(i32, i32)</code> is <code>Copy</code>, but <code>(i32, String)</code> is not.</p>
<p>然后一个反 其它语言编程常识的！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s&#x27;s value moves into the function...</span></span><br><span class="line">                                    <span class="comment">// ... and so is no longer valid here</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// 然而 在调用函数时 已经被drop了，现在 的s已经被move掉了 不可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class="line">  <span class="comment">// memory is freed.</span></span><br></pre></td></tr></table></figure>

<p><code>rust</code>的报错真好看</p>
<p>一个 非原始类型只能用一次？解决方案</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> 函数名(a_str: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">  a_str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多返回参数<code>fn 函数名(参数) -&gt; (String, usize) &#123; ... (xxx,yyy)&#125;</code></p>
<p>为了不用每一个 函数都这样写 来维持控制权， rust可以用引用来解决</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="reference"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理就是 函数并没有 获得 该<code>String</code>的<code>ownership</code>，而是只有其引用的，</p>
<p>所以如果我们 对<code>&amp;s</code>做<code>s.push_str(&quot;, world&quot;);</code>则会报错，不允许修改 默认 引用是 immutable</p>
<p>如果要修改<code>fn 函数名(参数名: &amp;mut String) &#123; 参数名.push_str(&quot;sdafsdfasd&quot;)&#125;</code></p>
<p><strong>限制</strong></p>
<p>对于同一个变量</p>
<p>一个<code>scope</code>里至多只能有一个 <code>mutable</code> 的引用</p>
<p>在有<code>immutable</code>引用的<code>scope</code>里，也不能有<code>mutable</code>的引用</p>
<p>多个<code>immutable</code>的引用时可以的,根据drop意义,以下是可行的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是r3不能移动到这个位置，因为有 immutable时候不能有mutable 的限制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// r1 and r2 are no longer used after this point</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之所以可以，是因为drop的原因，这里看作是所有immutable都已经drop掉了 ,所以他们的scope没有重叠</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// no problem</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure>

<p>总结描述就是任意一行代码上的<code>scope</code>对任意一个变量 要求<code>immutable*|mutable?</code></p>
<p>rust 编译时会检测 dangling references [如函数内创建的临时值，传出引用,会导致外部并不可用</p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>没有ownership的类型，slice让你 指向一个连续序列的某一段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sprefix</span> = &amp;s[..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ssuffix</span> = &amp;s[<span class="number">6</span>..];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ss</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>

<p><img data-src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="slice"></p>
<p>注意在utf-8下 取的slice坐标应该是合法的分割坐标</p>
<p>String slice类型是<code>&amp;str</code>,回顾之前字符串字面量</p>
<p><code>let s= &quot;hell world&quot;;</code>, 这里的s的类型就是<code>&amp;str</code></p>
<p>让函数接受参数是<code>&amp;str</code> 能让代码更加可用</p>
<p>其它 slice，如数值数组的slice，写法和上面类似 类型是<code>&amp;[i32]</code></p>
<h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><p>定义</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">struct</span>名&#123;</span><br><span class="line">  字段名<span class="number">1</span>:字段类型<span class="number">1</span>,</span><br><span class="line">  字段名<span class="number">2</span>:字段类型<span class="number">2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量名 = <span class="keyword">struct</span>名&#123;</span><br><span class="line">  字段名<span class="number">1</span>: 值<span class="number">1</span>,</span><br><span class="line">  字段名<span class="number">2</span>: 值<span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意的是，rust只允许整体上mutable or immutable,不允许 按字段来划分</p>
<p>在参数和字段保持一致时可以略写</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email, <span class="comment">// 这里可以略写作 email,</span></span><br><span class="line">        username: username, <span class="comment">// 这里可以略写作 username,</span></span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过其它的struct的部分字段一致造新的struct</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以写作</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>tuple structs! 没有字段名的struct</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Unit-Like:</p>
<p>注意到上面的类型是String，是因为我们希望结构体 有对应String的Ownership</p>
<p>如果用 slice，则会因为rust的生命周期管理而报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结构体 &#x2F;&#x2F; rust 的报错真的有意思 还有建议使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="comment">// 或者 &#123;:#?&#125; 可以 格式化样式输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>,other:&amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; <span class="comment">// 编译器知道self类型，我们只希望 操作 不希望take ownership,否则 &amp;mut self</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 可以拆分到多个impl 合法的语法 但不建议</span></span><br><span class="line"><span class="comment">//impl</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle&#123; <span class="comment">//</span></span><br><span class="line">      Rectangle &#123; width:size,height:size&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">square1</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于 <code>C++/C</code>的 <code>-&gt;</code> &#x3D;&#x3D; <code>(* ).</code></p>
<p>rust有自动 <code>referencing和dereferencing</code> ,都可以简写为<code>.</code></p>
<h1 id="Enums-and-Option-and-Pattern-Matching"><a href="#Enums-and-Option-and-Pattern-Matching" class="headerlink" title="Enums and Option and Pattern Matching"></a>Enums and Option and Pattern Matching</h1><p>定义枚举类型和成员</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型&#123;</span><br><span class="line">  枚举成员<span class="number">1</span>,</span><br><span class="line">  枚举成员<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = 枚举类型::枚举成员<span class="number">1</span></span><br><span class="line"></span><br><span class="line">枚举 的每个成员可以不同类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表转库的使用方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enum 也可以 impl方法函数</p>
<p>rust中不存在的概念下的枚举量 Option:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>

<p>Option 的意味，这 编写者，对于Option中的值并不确定 如 Option<i8></p>
<p>而直接的i8意味着 一定有有效值，所以<code>i8</code>和<code>Option&lt;i8&gt;</code>类型相加会报错，在使用Option中的值时， 需要把<code>Option&lt;T&gt;</code>中的<code>T</code>提取出来</p>
<p>Match 看上去像其它语言的switch</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title function_ invoke__">derive</span>(<span class="built_in">Debug</span>)]</span><br><span class="line"> <span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支持None的+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p> It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite. <del>自吹自擂</del></p>
<p>然而 如果你上面省去None，编译会报错，这就和switch有了差异，相当于强制 处理所有</p>
<p>这里有<code>_</code>可以匹配所有,不希望处理的可以在match最后<code>_ =&gt; ()</code></p>
<p>简洁控制流<code>if let</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_u8_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Managing-Growing-Projects-with-Packages-Crates-and-Modules"><a href="#Managing-Growing-Projects-with-Packages-Crates-and-Modules" class="headerlink" title="Managing Growing Projects with Packages, Crates, and Modules"></a>Managing Growing Projects with Packages, Crates, and Modules</h1><ul>
<li><code>Packages</code>: A Cargo feature that lets you build, test, and share crates</li>
<li><code>Crates</code>: A tree of modules that produces a library or executable</li>
<li><code>Modules</code> and <code>use</code>: Let you control the organization, scope, and privacy of paths</li>
<li><code>Paths</code>: A way of naming an item, such as a struct, function, or module</li>
</ul>
<h2 id="Packages-amp-Crates"><a href="#Packages-amp-Crates" class="headerlink" title="Packages &amp; Crates"></a>Packages &amp; Crates</h2><p><code>crate = binaray | library</code></p>
<p><code>package = (library crate)?+(binaray crate)*</code></p>
<p>回顾<code>cargo new my-project</code>创建出来的。</p>
<p>会发现<code>Cargo.toml</code>并不会包含<code>src/main.rs</code></p>
<p>是因为默认 <code>src/main.rs</code>会是binary的入口,会编译产生和project同名的二进制文件，同样<code>src/lib.rs</code>会是crate的library的入口</p>
<p>cargo会交给rustc 来build library或binary</p>
<p>A package can have multiple binary crates by placing files in the src&#x2F;bin directory: each file will be a separate binary crate.</p>
<p>如果像第二章里面引入rand，它会提供一个trait叫Rng</p>
<p>而如果我们自己也写了一个struct Rng，那么如果要用rand的，使用<code>rand::Rng</code></p>
<h2 id="Defining-Modules-to-Control-Scope-and-Privacy"><a href="#Defining-Modules-to-Control-Scope-and-Privacy" class="headerlink" title="Defining Modules to Control Scope and Privacy"></a>Defining Modules to Control Scope and Privacy</h2><ul>
<li><code>use</code> keyword that brings a path into scope</li>
<li><code>pub</code> keyword to make items public.</li>
<li><code>as</code></li>
</ul>
<p>文档这里用写一个餐厅举例</p>
<p><code>cargo new --lib restaurant</code></p>
<p>src&#x2F;lib.rs :</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123; <span class="comment">// 用mod 定义一个module</span></span><br><span class="line">    <span class="keyword">mod</span> hosting &#123; <span class="comment">// module 可以嵌套</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记得把<code>#[cfg(test)]</code>去掉</strong></p>
<p>这样分割后，别人阅读代码可以按照group分割找，相对于完全看一遍代码更友好</p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><ul>
<li>绝对路径create开头的</li>
<li>相对路径 self,super 或 当前module中的一个identifier</li>
</ul>
<p>例如对上面</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Relative path</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以上代码并不能通过编译，因为会有hosting is private</p>
<p>Modules aren’t only useful for organizing your code, they also define Rust’s privacy boundary</p>
<p>module的所有成员(functions, methods, structs, enums, modules, and constants) 默认全是private</p>
<p>父级别不能使用子级别的内部private方法，但是子级别可以用它祖先的方法…<del>废话</del></p>
<p>如果希望能被外部调用 上面的mod应该 改为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为相函数和<code>front_of_house</code>的位置是 同层级关系，所以最外的mod不需要pub</p>
<blockquote>
<p>super</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>(); <span class="comment">// 同级别</span></span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>(); <span class="comment">// 父级别</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要让一个mod中的 任何一个public，需要在每个需要的地方加上pub</p>
<h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><p>类似C++ <code>using namespace</code> ?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">// bring hosting module into the scope</span></span><br><span class="line"><span class="comment">// 相对路径写法 需要加上self::</span></span><br><span class="line"><span class="comment">// use self::front_of_house::hosting;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后上面这样是idiom的，虽然也可以<code>use crate::front_of_house::hosting::add_to_waitlist</code>然后 之后就省去<code>hosting::</code>,但根据大家书写习惯，建议这样,接受这个建议</p>
<p>不过无论怎么设计，随着3方库的越来越多，总会有重名&#x3D;。&#x3D;解决方案可以用<code>as</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h2><p><code>pub use crate::front_of_house::hosting;</code></p>
<p>这样对于外部代码可以用 <code>hosting::add_to_waitlist</code>来调用</p>
<h2 id="package-引入"><a href="#package-引入" class="headerlink" title="package 引入"></a>package 引入</h2><p>回想之前rand的 在<code>Cargo.toml</code>中添加和代码中引入</p>
<p><code>use std::&#123;cmp::Ordering, io&#125;;</code> 内嵌式引入</p>
<p>同时引入<code>std::io</code> 和 <code>std::io::Write</code>: <code>use std::io::&#123;self, Write&#125;;</code></p>
<p><code>use std::collections::*;</code></p>
<p>This use statement brings all public items defined in <code>std::collections</code> into the current scope. <strong>Be careful</strong> when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.</p>
<h2 id="模块分化"><a href="#模块分化" class="headerlink" title="模块分化"></a>模块分化</h2><p>当项目大了之后模块也会需要分化</p>
<blockquote>
<p>src&#x2F;lib.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;<span class="comment">// 分号结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于子模块</p>
<p>写法1:</p>
<blockquote>
<p><code>src/front_of_house.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2:</p>
<blockquote>
<p><code>src/front_of_house.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/front_of_house/hosting.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Common-Collections"><a href="#Common-Collections" class="headerlink" title="Common Collections"></a>Common Collections</h1><p>C++ STL即视感?</p>
<ul>
<li>A <code>vector</code> 允许你储存 变化数量的 值</li>
<li>A <code>string</code> is a collection of characters. 之前提到过 这章会更深入的讲解</li>
<li>A <code>hash map</code> allows you to associate a value with a particular key. 是 <code>map</code>的一个具体的实现版本.</li>
</ul>
<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><p><code>let v: Vec&lt;i32&gt; = Vec::new();</code></p>
<p>vector不知道你要存什么，他使用 generics(泛型)实现的<code>Vec&lt;T&gt;</code> &#x2F;&#x2F; 第10章会详细讲泛型</p>
<p>直接用值 <code>let v = vec![1, 2, 3];</code></p>
<p>操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>); <span class="comment">// push.....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>]; <span class="comment">// 需要多一个&amp;符号</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123; <span class="comment">// 返回的是 Option&lt;&amp;T&gt;</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the vector gets dropped, all of its contents are also dropped</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>]; <span class="comment">// immutable borrow occurs here</span></span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>); <span class="comment">// mutable borrow occurs here</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure>

<p>上面会挂掉，</p>
<ol>
<li>是因为 之前讲过的 rust关于 ownership的管理方法，</li>
<li>是虽然看上去读第一个元素和尾部加元素毫不影响, 但实际上可能rust的内部实现在 push时会 申请新的地址，并整个拷贝，这样的情况下 first会指向一个被释放了的内存地址。所以其实它们可能有关[其实根本还是 ownership</li>
</ol>
<blockquote>
<p>遍历</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可写</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过Enum支持 存储多种类型</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>怎么 这样看上去 就像 自己实现了一个struct，带一个变量标识类型，和 一个<code>void *</code>指针，然后说vector可以装这些 不同 类型 XD</p>
<p>但下面说 Rust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element.需要在编译时 知道 每个元素 需要的内存大小(max?) </p>
<h2 id="Storing-UTF-8-Encoded-Text-with-Strings"><a href="#Storing-UTF-8-Encoded-Text-with-Strings" class="headerlink" title="Storing UTF-8 Encoded Text with Strings"></a>Storing UTF-8 Encoded Text with Strings</h2><p>如果你从其它语言来，那么你可能因为string而自闭XD</p>
<p>string的实现是 a collection of bytes</p>
<p>core language: <code>string slice</code> : <code>str</code> ,常见的用法<code>&amp;str</code></p>
<p>standard library: 字符串( growable, mutable, owned, UTF-8 encoded string type) : <code>String</code></p>
<p>String 创建</p>
<p>下面两个函数做同样的事情</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量 + to_string()</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// String::from(字面量)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial contents&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">s1.<span class="title function_ invoke__">push_str</span>(s2); <span class="comment">// push_str 不会拿ownership</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// s1 被 moved，之后就不能用了, 但是s2是引用的使用方法，所以之后还是可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// + 使用的方法是形如 fn add(self, s: &amp;str) -&gt; String ， add 真实的是使用 泛型实现</span></span><br></pre></td></tr></table></figure>

<p>&amp;s2的类型是<code>&amp;String</code> ，被rust通过<code>deref coercion</code>转换为 <code>&amp;s2[..]</code>,也就是类型<code>&amp;str</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);<span class="comment">// 易读 而且 不会对参数 take ownership</span></span><br></pre></td></tr></table></figure>

<p>蛋是,想直接访问s1[0]并不可行<code>std::string::String cannot be indexed by &#123;integer&#125;</code></p>
<p><code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code></p>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>).<span class="title function_ invoke__">len</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>).<span class="title function_ invoke__">len</span>(); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>如上两个 因为有<code>UTF-8</code>的编码，所以 简单的 index去描述 会难以理解</p>
<p>因为有3种看待String的方式</p>
<ul>
<li>as bytes,</li>
<li>scalar values, </li>
<li>and grapheme clusters (the closest thing to what we would call letters).</li>
</ul>
<p>对于 “नमस्ते”</p>
<ol>
<li><p>我们以u8为单位看<code>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]</code></p>
</li>
<li><p>以Unicode scalar value 看<code>[&#39;न&#39;, &#39;म&#39;, &#39;स&#39;, &#39;्&#39;, &#39;त&#39;, &#39;े&#39;]</code></p>
</li>
<li><p>以<code>grapheme clusters</code>看<code>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</code></p>
</li>
</ol>
<p>可行的String操作</p>
<blockquote>
<p>1</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>]; <span class="comment">// 类型&amp;str ,值为 Зд</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是一个非法的分割字符，则会 panic</p>
<blockquote>
<p>2</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Storing-Keys-with-Associated-Values-in-Hash-Maps"><a href="#Storing-Keys-with-Associated-Values-in-Hash-Maps" class="headerlink" title="Storing Keys with Associated Values in Hash Maps"></a>Storing Keys with Associated Values in Hash Maps</h2><p><code>HashMap&lt;K, V&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>所有的key需要同样的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把</span><br><span class="line">[&quot;Blue&quot;,&quot;Yellow&quot;]</span><br><span class="line">[10,50]</span><br><span class="line">变为</span><br><span class="line">&#123;&quot;Blue&quot;:10,&quot;Yellow&quot;:50&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>注意的是，insert的操作会拿取ownership</p>
<blockquote>
<p>读取</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>

<p>get返回的是<code>Option&lt;&amp;V&gt;</code>类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<p>调用insert可以更新 原来的值</p>
<p><code>scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);</code></p>
<p>entry来看是否存在，如果存在则无后续操作，如果不存在则插入值</p>
<blockquote>
<p>基于原来的值更新</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">*count += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>By default, HashMap uses a “cryptographically strong”1 hashing function that can provide resistance to Denial of Service (DoS) attacks !!!!!</p>
<h1 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h1><p>错误分为<code>recoverable</code> 和 <code>unrecoverable errors</code></p>
<p>Rust 没有exceptions， 它只有<code>type Result&lt;T, E&gt;</code></p>
<h2 id="不可恢复的错误with-panic"><a href="#不可恢复的错误with-panic" class="headerlink" title="不可恢复的错误with panic!"></a>不可恢复的错误with panic!</h2><p>当调用<code>panic!</code>时 macro executes, your program will print a failure message, unwind and clean up the stack, and then quit</p>
<p>panic发生时，默认行为 the program starts unwinding, which means Rust walks back up the stack and cleans up the data from each function it encounters</p>
<p>你也可以通过在Cargo.toml的 <code>[profile]</code>部分 增加<code>panic=&#39;abort&#39;</code>来 达到一旦panic直接<code>abort</code>的效果,如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = &#x27;abort&#x27;</span><br></pre></td></tr></table></figure>

<p>在终端里<code>export RUST_BACKTRACE=1</code>或者 <code>RUST_BACKTRACE=1 cargo run</code>可以让panic时输出栈信息</p>
<h2 id="Recoverable-Errors-with-Result"><a href="#Recoverable-Errors-with-Result" class="headerlink" title="Recoverable Errors with Result"></a>Recoverable Errors with Result</h2><p>Result的样子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如 打开文件 的返回就是<code>Result&lt;std::fs::File,std::io::Error&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到的是Result被默认 引入，所以不需要在Ok和Err前加上<code>Result::</code></p>
<p>我们这里 打开文件，如果成功直接 <code>Ok(file)=&gt;file</code> ,如果发生错误，则根据错误的类型判断,来进行不同操作</p>
<p>以上出现了很多match，也可以写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有更简洁的unwrap(正确返回 错误则panic) : <code>let f = File::open(&quot;hello.txt&quot;).unwrap();</code></p>
<p> If the Result value is the Ok variant, unwrap will return the value inside the Ok. If the Result is the Err variant, unwrap will call the <code>panic! macro</code> for us. Here is an example of unwrap in action</p>
<p>还有一个<code>expect</code> 和unwrap一样，但是可以多传参想展示的错误信息<code>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);</code></p>
<p>你可以在 match中不处理错误 手动的return 给Err，让上层函数来处理, [就是Exception那个</p>
<p>对于传递错误的可以 简写为 <code>?</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main里使用<code>?</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="To-panic-or-Not-to-panic"><a href="#To-panic-or-Not-to-panic" class="headerlink" title="To panic! or Not to panic!"></a>To panic! or Not to panic!</h2><p>本节讨论 panic的时机</p>
<p>在代码原型上和测试代码中，使用panic,如用unwrap，可以 既让你的代码保持干净，也能让你明确知道哪里还没有做处理</p>
<p>当你有比编译器更多的信息时，如你通过一些检查 明确这里不可能发生panic时，直接unwrap(),比如 ip访问127.0.0.1</p>
<p>当你的代码 进入一个<code>bad state</code>时 建议panic,这里<code>bad state</code>指的 assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code—plus one or more of the following:</p>
<ul>
<li>The bad state is not something that’s expected to happen occasionally.</li>
<li>Your code after this point needs to rely on not being in this bad state.</li>
<li>There’s not a good way to encode this information in the types you use.</li>
</ul>
<p>感觉这个就有点像 使用assert</p>
<p>除此以外更建议使用 类型 来做保证，利用rust编译时检查来保护</p>
<p>另一个办法是自定义一个类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之 处理不了则 panic!,可以处理 或 有可能处理 等等的其它情况 Result</p>
<h1 id="Generic-Types-Traits-and-Lifetimes"><a href="#Generic-Types-Traits-and-Lifetimes" class="headerlink" title="Generic Types, Traits, and Lifetimes"></a>Generic Types, Traits, and Lifetimes</h1><p>上面章节 我们已经用过的有 <code>Option&lt;T&gt;</code>,<code>Vec&lt;T&gt;</code>,<code>HashMap&lt;K,V&gt;</code>,<code>Result&lt;T,E&gt;</code></p>
<p><del>道理我都懂，为什么tutorial要这样举例 没把tutorial的例子移动过来 要看的话 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch10-00-generics.html">https://doc.rust-lang.org/book/ch10-00-generics.html</a></del></p>
<h2 id="Generic-Data-Types"><a href="#Generic-Data-Types" class="headerlink" title="Generic Data Types"></a>Generic Data Types</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面代码会报错,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T`</span><br><span class="line"> --&gt; src/main.rs:5:12</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ^^^^^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`</span><br></pre></td></tr></table></figure>

<p>相对于C++的template来说，如果是这种int char类型的话 并不会报错,对于自己定义的struct的话，自己实现<code>operator &gt;</code>也就能用</p>
<p>关于如何解决 后续讨论</p>
<p>在struct中使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Point&lt;T&gt;</code>上实现一个<code>x()</code>方法能够返回<code>x</code>字段的引用</p>
<p>对于一个具体的类型的函数定义和方法实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>You might be wondering whether there is a runtime cost when you’re using generic type parameters. The good news is that Rust implements generics in such a way that your code doesn’t run any slower using generic types than it would with concrete types.</p>
<p>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.</p>
<p>编译时,所以运行时没有使用generics的代价</p>
<h2 id="Traits-Defining-Shared-Behavior"><a href="#Traits-Defining-Shared-Behavior" class="headerlink" title="Traits: Defining Shared Behavior"></a>Traits: Defining Shared Behavior</h2><p>Note: Traits are similar to a feature often called interfaces in other languages, although with some differences.</p>
<p><code>src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;<span class="comment">// 这里使用 分号 具体要实现的每个类型去实现:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在struct上分别 实现 trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是写在同一个文件中，如果有涉及到分分间，需要注意让 我们的trait是pub，这样其它需要实现其内部方法的 通过<code>use 文件名::Summary</code>来引入</p>
<p>But we can’t implement external traits on external types. For example, we can’t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren’t local to our <code>aggregator</code> crate. This restriction is part of a property of programs called coherence, and more specifically the orphan rule, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
<p>在上面 trait定义中 可以提供默认实现，然后在使用这个默认实现时写<code>impl Summary for NewsArticle &#123;&#125;</code></p>
<p>默认的 trait的方法可以调用同一个trait里的其他方法,即使其它的方法没有被实现</p>
<p>假设有A,B,C 3个方法，A提供了默认实现，调用了B和C，那么意味着我们对于一个具体的struct 实现了B 和C 那么就可以自然的调用A 方法了</p>
<h3 id="把trait作为参数"><a href="#把trait作为参数" class="headerlink" title="把trait作为参数"></a>把trait作为参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>impl Trait</code>语法实际是语法糖，<code>trait bound</code>，大概长这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pub fn notify(item1: impl Summary, item2: impl Summary) &#123;</code> 这样 并没有限制 item1 和item2的类型，它们可以时不同类型</p>
<p>如果我们写成<code>pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) &#123;</code>则可以限制他们的类型为同一类型</p>
<p>关于限制，同时限制满足多个trait</p>
<p><code>pub fn notify(item: impl Summary + Display) &#123;</code> 这样 需要同时实现Summary和Display才能</p>
<p><code>pub fn notify&lt;T: Summary + Display&gt;(item: T) &#123;</code> 也可以这样使用</p>
<p>用<code>where</code>美化trait限制的书写</p>
<p>原本</p>
<p><code>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 &#123;</code></p>
<p>改写为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>在返回值的地方也可以使用<code>impl Trait</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>but the code calling this function doesn’t know that.</code></p>
<p>这里举例说 例如在<code>Iterator</code>之类的使用情景下，让你不需要关注具体，只需要关注功能实现</p>
<p>但是,实际只能返回单一类型..(由于它的实现原理)</p>
<p>假设A 和 B 都实现了Summary, 但是 你不可以使用<code>if somestate &#123; A &#123;&#125; &#125;else &#123; B&#123;&#125; &#125;</code>来返回</p>
<hr>
<p>我们回到<code>Generic Data Types</code>讲的那个比大小的代码</p>
<p>大于号会用到Rust中 的 <code>std::cmp::PartialOrd</code></p>
<p><code>fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</code> 并不能简单的解决问题</p>
<p>为了让我们的largest 只支持 我们实现过PartialOrd 和Copy (char和i32默认实现了)的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们不希望限制 largest函数 限制 需要实现<code>Copy</code>,我们可以用<code>Clone</code>代替<code>Copy</code>，意味着我们需要 使用更多的heap allocations,对于大数据来说，会让速度下降很多</p>
<blockquote>
<p>Another way we could implement largest is for the function to return a reference to a T value in the slice. If we change the return type to &amp;T instead of T, thereby changing the body of the function to return a reference, we wouldn’t need the Clone or Copy trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</p>
</blockquote>
<p>答案:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = &amp;item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以发现通过 限制 不同的trait 能够 有条件的实现 指定范畴内的 方法</p>
<p>例如标准库在任何type上实现了 <code>ToString</code> Trait</p>
<p>the standard library implements the <code>ToString</code> trait on any type that implements the <code>Display</code> trait. The <code>impl</code> block in the standard library looks similar to this code:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Validating-References-with-Lifetimes"><a href="#Validating-References-with-Lifetimes" class="headerlink" title="Validating References with Lifetimes"></a>Validating References with Lifetimes</h2><p>Rust编译器有一个<code>borrow checker</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br><span class="line"><span class="comment">// 正确的 data has a longer lifetime than the reference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ----------+-- &#x27;b</span></span><br><span class="line">                          <span class="comment">//           |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;a  |</span></span><br><span class="line">                          <span class="comment">//   |       |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |       |</span></span><br><span class="line">                          <span class="comment">// --+       |</span></span><br><span class="line">&#125;                         <span class="comment">// ----------+</span></span><br></pre></td></tr></table></figure>

<p>有问题的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于编译时来说，你不知道x和y的生命周期，当然编译器更不知道x和y的生命周期</p>
<h3 id="生命周期注解"><a href="#生命周期注解" class="headerlink" title="生命周期注解"></a>生命周期注解</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>

<p>单个注解无意义</p>
<p>For example, let’s say we have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p>
<p>上面的代码修复为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是 这并不会改变任何的存活时间????,这只会保证 lifetime的合法性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误 并不能给string2续命</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thinking-in-Terms-of-Lifetimes-从生命周期的角度思考"><a href="#Thinking-in-Terms-of-Lifetimes-从生命周期的角度思考" class="headerlink" title="Thinking in Terms of Lifetimes 从生命周期的角度思考"></a>Thinking in Terms of Lifetimes 从生命周期的角度思考</h3><p>注意的是，你只用标注有关联的，如下 当y和 结果无关联时，不写注解也能通过编译</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从理论上讲对引用来说 至少有一个入参和它的生命周期相关，如果全无关，全是函数内部产生的，那么显然在函数结束的时候，会被drop掉，那么返回的引用也就无效了</p>
<p>在 struct中也可以使用 生命周期注解</p>
<p>在历史版本的代码中Rust 需要很多的 生命周期注解，后来Rust team 发现 有许多是可推断的，也就是可省略的<code>lifetime elision rules</code></p>
<p>在未来，可能需要的 生命周期注解会更少</p>
<p>总的来说 ，平时编码你不需要过多关注，如果有编译器无法推断的情况，它会抛错，请你提供注解</p>
<ol>
<li>函数或方法 参数的Lifetimes称作 input lifetimes,</li>
<li>返回值上的lifetimes 称作 output lifetimes.</li>
</ol>
<p>编译器用3条规则来推测</p>
<ol>
<li>每一个 input 变量 对应单独一个 lifetimes,也就是有几个参数就有几个不同的Lifetimes</li>
<li>如果只有一个input Lifetimes 参数,那么 它的lifetimes会被应用到所有 out lifetimes参数</li>
<li>如果是个方法，也就是参数中有 <code>&amp;self</code>或<code>&amp;mut self</code> 那么<code>self</code>的lifetime会被 应用到所有output lifetime</li>
</ol>
<h3 id="Lifetime-Annotations-in-Method-Definitions"><a href="#Lifetime-Annotations-in-Method-Definitions" class="headerlink" title="Lifetime Annotations in Method Definitions"></a>Lifetime Annotations in Method Definitions</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值根据规则3 和self一样</p>
<h3 id="The-Static-Lifetime"><a href="#The-Static-Lifetime" class="headerlink" title="The Static Lifetime"></a>The Static Lifetime</h3><p>通过如下的<code>&#39;static</code>注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的注解意味着 生命周期 占整个程序，建议可用的地方有 错误提示信息的字串</p>
<h3 id="Generic-Type-Parameters-Trait-Bounds-and-Lifetimes-Together"><a href="#Generic-Type-Parameters-Trait-Bounds-and-Lifetimes-Together" class="headerlink" title="Generic Type Parameters, Trait Bounds, and Lifetimes Together"></a>Generic Type Parameters, Trait Bounds, and Lifetimes Together</h3><p>all in one</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Writing-Automated-Tests"><a href="#Writing-Automated-Tests" class="headerlink" title="Writing Automated Tests"></a>Writing Automated Tests</h1><h2 id="How-to-Write-Tests"><a href="#How-to-Write-Tests" class="headerlink" title="How to Write Tests"></a>How to Write Tests</h2><p>基本3个步骤</p>
<ol>
<li>设置依赖的数据和状态</li>
<li>运行你想要测试的代码</li>
<li>验证结果 和期望的一致</li>
</ol>
<p>在函数前加上<code>#[test]</code>，当你运行cargo test时，<code>cargo</code>会调用他们</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo new adder --lib</span><br><span class="line"><span class="built_in">cd</span> adder</span><br><span class="line">vim src/lib.rs</span><br></pre></td></tr></table></figure>

<p>运行 <code>cargo test</code></p>
<p>下面我们把<code>src/lib.rs</code>换成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增文件<code>src/test.rs</code>   感觉 tutorial 这里写错了(吗?)，这里写的还是<code>src/lib.rs</code>虽然把下面一段代码放在上面代码后面也可以运行</p>
<p>**补,注:**看完这一章后 我去掉了<code>test.rs</code>把 测试代码放在实现代码同一份代码的下部</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123; width: <span class="number">8</span>, height: <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123; width: <span class="number">5</span>, height: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">smaller_cannot_hold_larger</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123; width: <span class="number">8</span>, height: <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123; width: <span class="number">5</span>, height: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(!smaller.<span class="title function_ invoke__">can_hold</span>(&amp;larger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src</code>下的样子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── lib.rs</span><br><span class="line">└── test.rs</span><br></pre></td></tr></table></figure>

<p>运行<code>cargo test</code>,忽略那些黄色的warning提示，能成功通过<code>assert</code></p>
<p>测试常用的宏:</p>
<ul>
<li><code>assert!</code></li>
<li><code>assert_eq!</code></li>
<li><code>assert_ne!</code></li>
</ul>
<p>相对于 <code>手动assert</code> + <code>== 运算</code>来说 ，后面两种方法 会自动带出 输入的值</p>
<p>根据后面两个宏的实现原理，你传入的struct需要同时实现<code>PartialEq</code>和<code>Debug</code>两个trait</p>
<p>通常会在你的struct或enum前加上 <code>#[derive(PartialEq, Debug)]</code></p>
<p>可以自定义额外的输出消息</p>
<p><code>assert!(表达式,额外的输出消息)</code></p>
<blockquote>
<p><code>#[should_panic]</code>来 检测panic是否发生</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更精确的 panic,增加expected</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试代码中使用<code>Result&lt;T,E&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code></p>
<h2 id="Controlling-How-Tests-Are-Run"><a href="#Controlling-How-Tests-Are-Run" class="headerlink" title="Controlling How Tests Are Run"></a>Controlling How Tests Are Run</h2><p>默认的 test是并行运行的!</p>
<p>如果你的不同测试会读写同一个文件,那么可能在测试中有冲突，<code>cargo test -- --test-threads=1</code>可以让只有一个测试线程</p>
<p>函数的输出，当测试成功时，你<strong>不会</strong>在terminal看到 被测试程序中的输出，当测试失败时，你<strong>会</strong>看到所有被测试程序过程中的输出</p>
<p><code>cargo test -- --nocapture</code> 可以让 程序的过车给你输出始终能看到</p>
<p>运行一定条件函数名测试<code>cargo test &lt;希望被函数名包含的字符串&gt;</code>,同时在输出中,你会看到<code>XXX filtered out</code></p>
<p>如<code>cargo test add</code>只会运行 函数名中有<code>add</code>的测试方法</p>
<p>对于一些测试可能很耗时或其它原因你希望默认忽略,那么加上<code>#[ignore]</code>在 <code>#[test]</code>的下一行</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">    <span class="comment">// code that takes an hour to run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样默认<code>cargo test</code>它不会被运行</p>
<p>我们可以通过<code>cargo test -- --ignored</code>来调用这些被标注<code>#[ignore]</code>的函数</p>
<h2 id="Test-Organization"><a href="#Test-Organization" class="headerlink" title="Test Organization"></a>Test Organization</h2><p>把测试分为两个类型:单元测试和交互测试</p>
<h3 id="Unit-Tests"><a href="#Unit-Tests" class="headerlink" title="Unit Tests"></a>Unit Tests</h3><p>You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with <code>cfg(test)</code>.</p>
<p>测试module</p>
<p><code>#[cfg(test)]</code>注解告诉 只有运行<code>cargo test</code>时才会编译和运行</p>
<p>也就是<code>cargo build</code>并不会理有这样注解的</p>
<p>测试私有的函数!<code>other languages make it difficult or impossible to test private functions</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">internal</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integration-Tests"><a href="#Integration-Tests" class="headerlink" title="Integration Tests"></a>Integration Tests</h3><p>区别于单元测试，交互测试，会如同正常的代码调用去模拟</p>
<p>在我们项目的顶层 创建一个<code>tests</code>文件夹 和<code>src</code>同级别,<code>cargo</code>会在这个文件夹中 找交互测试的文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder; <span class="comment">// 我们在单元测试中不会需要这个, 而</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也不需要任何<code>#[cfg(test)]</code>,因为整个文件夹 都会被视作<code>cargo test</code>使用的</p>
<p>文件<code>src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>cargo test</code>全ok即可</p>
<p>指定测试<strong>文件名</strong><code>cargo test --test integration_test</code></p>
<p>如果你在tests下建立了一个 <code>common.rs</code>,即使你没有在里面写测试函数，你运行<code>cargo test</code>时，在输出中依然能看到它</p>
<p>我们 把<code>src/common.rs</code>改成 <code>src/common/mod.rs</code></p>
<p>这样的命名文件方式 告诉Rust 不要把<code>common</code> module 视作 交互测试文件,其它文件可以调用它</p>
<blockquote>
<p><code>tests/integration_test.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tests/common/mod.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上的分解文件能实现</p>
<ol>
<li>不同的测试文件都可以调用<code>common/mod.rs</code>里的方法</li>
<li>但<code>cargo test</code>不会把 <code>common/mod.rs</code>直接视作 交互测试文件</li>
</ol>
<h4 id="Integration-Tests-for-Binary-Crates"><a href="#Integration-Tests-for-Binary-Crates" class="headerlink" title="Integration Tests for Binary Crates"></a>Integration Tests for Binary Crates</h4><p>如果，我是说如果，我们的工程是 binary crate，也就是没有<code>src/lib.rs</code>,只有<code>src/main.rs</code></p>
<p>那么我们不能 通过 上面tests文件夹 的 交互测试方法，来 bring <code>src/main.rs</code> 中定义的函数</p>
<p>原因是:Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</p>
<p>从 分化的哲学上说，如果复杂的功能(被分化到src&#x2F;lib.rs中的)测试都没问题，那么少量的<code>src/main.rs</code>正常工作不需要测试?</p>
<p>不太认可这种(少量代码 就不需要测试)的观点，但反过来看，这种设计能带来的结果会促使代码的分化，留更少的逻辑在main中,XD</p>
<h1 id="An-I-x2F-O-Project-Building-a-Command-Line-Program"><a href="#An-I-x2F-O-Project-Building-a-Command-Line-Program" class="headerlink" title="An I&#x2F;O Project: Building a Command Line Program"></a>An I&#x2F;O Project: Building a Command Line Program</h1><blockquote>
<p>英语小课堂</p>
</blockquote>
<p>have sth. under your belt,</p>
<p>你已经有经验的某事&#x2F; 已经掌握</p>
<ol>
<li>In one’s scope of experience.</li>
</ol>
<p>Once you get a few more major league games under your belt, you’ll feel more comfortable.</p>
<p>吸收或消化 </p>
<ol start="2">
<li>Ingested or consumed.</li>
</ol>
<p>He should be less cranky after he gets some food under his belt.</p>
<hr>
<p>本章 打算搞个grep(globally search a regular expression and print) , 经常在linux开发的应该是再熟不过的命令了</p>
<p>Rust 社区成员 <code>Andrew Gallant</code>已经完成了一个 完整版的<code>ripgrep</code></p>
<p>本章只会实现一些简单的功能，因为本章的目的还是</p>
<ol>
<li>回顾你所学的，</li>
<li>熟悉一些新的库函数</li>
</ol>
<p>本章包含内容</p>
<ul>
<li>组织代码(chapter 7)</li>
<li>使用Vec和String (chapter 8)</li>
<li>处理错误(chapter 9)</li>
<li>Using traits and lifetimes where appropriate(chapter 10)</li>
<li>编写测试(chapter 11)</li>
</ul>
<h2 id="接受命令行参数"><a href="#接受命令行参数" class="headerlink" title="接受命令行参数"></a>接受命令行参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new minigrep &amp;&amp; <span class="built_in">cd</span> minigrep</span><br></pre></td></tr></table></figure>

<p><del>有写过py脚本 或者shell脚本的 应该经常用相应语言写过解析了</del></p>
<p>使用<code>std::env::args</code>来读取参数</p>
<p>如果你需要你的程序接受无效的Unicode,请尝试<code>std::env::args_os</code></p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 <code>cargo run par1 par2</code></p>
<h2 id="Reading-a-File"><a href="#Reading-a-File" class="headerlink" title="Reading a File"></a>Reading a File</h2><p>先建一个文件 让我们读</p>
<blockquote>
<p><code>poem.txt</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试<code>cargo run the poem.txt</code></p>
<h2 id="Refactoring-to-Improve-Modularity-and-Error-Handling"><a href="#Refactoring-to-Improve-Modularity-and-Error-Handling" class="headerlink" title="Refactoring to Improve Modularity and Error Handling"></a>Refactoring to Improve Modularity and Error Handling</h2><p>拆分重构</p>
<p><code>main</code>中应该 只有</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a run function in lib.rs</li>
<li>Handling the error if run returns an error</li>
</ul>
<p><strong>官方tutorial的重构 步骤比我这里记录的更细致！包括先换成tuple，再换成struct，再设计new等等</strong></p>
<p>文件目录<code>src</code>结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── lib.rs</span><br><span class="line">└── main.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(); <span class="comment">// There’s a tendency among many Rustaceans to avoid using clone to fix ownership problems because of its runtime cost. In Chapter 13, you’ll learn how to use more efficient methods in this type of situation. But for now, it’s okay to copy a few strings to continue making progress because you’ll make these copies only once and your filename and query string are very small. It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it’ll be easier to start with the most efficient solution, but for now, it’s perfectly acceptable to call clone.</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123; <span class="comment">// Box&lt;dyn Error&gt; means the function will return a type that implements the Error trait, but we don’t have to specify what particular type the return value will be</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Developing-the-Library’s-Functionality-with-Test-Driven-Development"><a href="#Developing-the-Library’s-Functionality-with-Test-Driven-Development" class="headerlink" title="Developing the Library’s Functionality with Test-Driven Development"></a>Developing the Library’s Functionality with Test-Driven Development</h2><p>TDD !!!! 以前写python时尝试过，始终没有一个很好的实践</p>
<ol>
<li>Write a test that fails and run it to make sure it fails for the reason you expect.</li>
<li>Write or modify <code>just enough code</code> to make the new test pass.</li>
<li>Refactor the code you <code>just added or changed</code> and make sure the tests continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>This process is just one of many ways to write software, but TDD can help drive code design as well. </p>
<p>看上去这种过程比我之前的会好很多</p>
<p>我之前TDD的过程，有以下问题</p>
<ol>
<li>在尝试在一开始，就想把所有 必要不必要，主流程，辅流程考虑完，实际根本无法完成</li>
<li>尝试在一开始就写足量的测试，但实际上，很难一开始就足量</li>
<li>进行过程中，一边改代码，一边改测试，没有编码和写测试的分化逐渐模糊</li>
<li>没有循环的环，想是 想，1写完 测试，2写完代码</li>
</ol>
<p>相比之下，上面的过程,意味着不要一步到位，每次测试编写只关注,“当前版本”期望解决的问题，然后，明确分化了 测试编写和代码编写。最后有迭代环。</p>
<p>先编写测试代码, 在<code>src/lib.rs</code>文件后加上</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终 成果</p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(); <span class="comment">// There’s a tendency among many Rustaceans to avoid using clone to fix ownership problems because of its runtime cost. In Chapter 13, you’ll learn how to use more efficient methods in this type of situation. But for now, it’s okay to copy a few strings to continue making progress because you’ll make these copies only once and your filename and query string are very small. It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it’ll be easier to start with the most efficient solution, but for now, it’s perfectly acceptable to call clone.</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123; <span class="comment">// Box&lt;dyn Error&gt; means the function will return a type that implements the Error trait, but we don’t have to specify what particular type the return value will be</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有加 &#x27;a (lifetime specifier) :this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是上面的测试代码</span></span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<h2 id="Working-with-Environment-Variables"><a href="#Working-with-Environment-Variables" class="headerlink" title="Working with Environment Variables"></a>Working with Environment Variables</h2><p>增加功能，用户可以配置环境变量，设置 大小写不敏感</p>
<p>在刚刚的测试代码中增加 新的测试</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... 和另一个 #[test]同层级</span></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;rUsT&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Trust me.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Rust:&quot;</span>, <span class="string">&quot;Trust me.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>大小写敏感搜索实现代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法实现了，下面要做的是 用户可以 通过 环境变量来决定是否是否使用大小写敏感</p>
<p>通过<code>env::vars</code> 来读取环境变量</p>
<p>最终实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_insensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_insensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>(); <span class="comment">// 读取环境变量</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, filename, case_insensitive &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_insensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query,&amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;rUsT&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Trust me.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Rust:&quot;</span>, <span class="string">&quot;Trust me.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别运行以下命令，观察输出的差异</p>
<p><code>cargo run to poem.txt</code></p>
<p><code>CASE_INSENSITIVE=1 cargo run to poem.txt</code></p>
<h2 id="Writing-Error-Messages-to-Standard-Error-Instead-of-Standard-Output"><a href="#Writing-Error-Messages-to-Standard-Error-Instead-of-Standard-Output" class="headerlink" title="Writing Error Messages to Standard Error Instead of Standard Output"></a>Writing Error Messages to Standard Error Instead of Standard Output</h2><p>有经常用linux命令的 都知道 输出有 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Standard_streams">标准输出和错误输出</a></p>
<p>把 错误输出的<code>println!</code> 换成 <code>eprintln!</code> 即可</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了 下面你可以用 重定向输出发现，我们 把 错误信息输出到stderr了</p>
<h2 id="回顾TDD"><a href="#回顾TDD" class="headerlink" title="回顾TDD"></a>回顾TDD</h2><p>我们上面的步骤为</p>
<ol>
<li>首先编写最外的框架，分离main和lib</li>
<li>编写初代的测试代码，针对我们的关键运算函数</li>
<li>实现函数 通过测试</li>
<li>完成其它功能，比如调用这个运算函数，增加输入输出提示</li>
<li>完成，为新的功能编写测试代码，跳到第3步</li>
</ol>
<h1 id="Functional-Language-Features-Iterators-and-Closures"><a href="#Functional-Language-Features-Iterators-and-Closures" class="headerlink" title="Functional Language Features: Iterators and Closures"></a>Functional Language Features: Iterators and Closures</h1><ul>
<li>Closures, a function-like construct you can store in a variable</li>
<li>Iterators, a way of processing a series of elements</li>
<li>How to use these two features to improve the I&#x2F;O project in Chapter 12</li>
<li>The performance of these two features (Spoiler alert: they’re faster than you might think!)</li>
</ul>
<h2 id="Closures-Anonymous-Functions-that-Can-Capture-Their-Environment"><a href="#Closures-Anonymous-Functions-that-Can-Capture-Their-Environment" class="headerlink" title="Closures: Anonymous Functions that Can Capture Their Environment"></a>Closures: Anonymous Functions that Can Capture Their Environment</h2><p>闭包</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> 函数名字(...)&#123;</span><br><span class="line">  <span class="keyword">let</span> 值 = 某个耗时运算</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ... &#123;</span><br><span class="line">    使用 值</span><br><span class="line">    使用 值</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span>(...) &#123;</span><br><span class="line">    使用 值</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    不使用 值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望只有需要运算结果，才会执行. 这有一个闭包的应用场景。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个闭包，把它存在<code>expensive_closure</code>变量中</p>
<p>我们用的单个参数<code>|num|</code>如果要多个，用逗号隔开,<code>|param1,param2|</code></p>
<p>注意，let statement意味着<code>expensive_closure</code> 包含一个匿名函数的定义，不是包含一个匿名函数调用的返回值</p>
<p>改成如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">    <span class="comment">// 通常 因为有上下文 和 可推断 不需要注解,但是 如果使用时，用不同类型调用则会报错</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">expensive_closure</span>(intensity) <span class="comment">// 闭包调用</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">expensive_closure</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">expensive_closure</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它书写方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</p>
</blockquote>
<p><code>memoization</code> or <code>lazy evaluation.</code></p>
<p>有三种闭包实现，要么是<code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要拿值的时候调用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  // 初始化值</span><br><span class="line">  let mut expensive_result = Cacher::new(|num| &#123;</span><br><span class="line">        println!(&quot;calculating slowly...&quot;);</span><br><span class="line">        thread::sleep(Duration::from_secs(2));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line">  // 获取值</span><br><span class="line">  expensive_result.value(intensity)</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">在目前实现上，只有首次调用value的intensity会有效，其它的暂时没有区别</span><br><span class="line"></span><br><span class="line">第二个问题是 目前只支持u32,尝试让它支持更多类型</span><br><span class="line"></span><br><span class="line">&gt; Capturing the Environment with Closures</span><br><span class="line"></span><br><span class="line">闭包能读取它所在环境中的变量</span><br><span class="line"></span><br><span class="line">```rust</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 4;</span><br><span class="line"></span><br><span class="line">    let equal_to_x = |z| z == x;// taking ownership, borrowing mutably, and borrowing immutably</span><br><span class="line">    // 注意 不能换成 fn equal_to_x(z: i32) -&gt; bool &#123; z == x &#125; 这样函数写法而不是闭包写法 无法读取外部x</span><br><span class="line"></span><br><span class="line">    let y = 4;</span><br><span class="line"></span><br><span class="line">    assert!(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure’s environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The Once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</li>
<li>FnMut 可以改变环境里的变量，</li>
<li>Fn borrows values from the environment immutably.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="comment">// 对于非基础类型来说 -------- value moved (into closure) here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们加了<code>move</code>关键字，当闭包被定义时， 值就被移动到闭包内</p>
<h2 id="Processing-a-Series-of-Items-with-Iterators"><a href="#Processing-a-Series-of-Items-with-Iterators" class="headerlink" title="Processing a Series of Items with Iterators"></a>Processing a Series of Items with Iterators</h2><p>iterators are <code>lazy</code> 创建时，不会消耗iterator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let v1 = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">// 创建</span><br><span class="line">let v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">// 遍历</span><br><span class="line">for val in v1_iter &#123; // We didn’t need to make v1_iter mutable when we used a for loop because the loop took ownership of v1_iter and made it mutable behind the scenes.</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自己的可iterable:只要实现 Iterator的trait</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    // 新的语法: type Item and Self::Item, which are defining an associated type with this trait.</span><br><span class="line"></span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    // methods with default implementations elided</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过next遍历</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们想 创建一个会拿ownership的 并能返回owned values的,调用<code>into_iter</code> 取代 <code>iter</code>. 类似如果我们想遍历，mutable references,我们调用<code>iter_mut</code>来替代<code>iter</code>,这谁设计的名字?怎么一个加前缀一个后缀</p>
<p>Methods that call <code>next</code> are called <code>consuming adaptors</code>,例如 <code>sum</code> 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">iterator_sum</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里意味着 v1_iter 不再可用，因为sum 拿取了ownership</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Other methods defined on the <code>Iterator</code> trait, known as <code>iterator adaptors</code></p>
<p>比如 <code>v1.iter().map(...)</code> 的<code>map</code>，iterator adaptors are lazy, and we need to consume the iterator here.</p>
<p>直接<code>v1.iter().map(|x| x+1)</code>会报错，因为没有消耗iterator</p>
<p>解决方案是<code>collect</code>一个会消耗<code>iterator</code>的方法,它收集返回值到一个新的 collection data type</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<p><code>filter</code>方法 是 iterator adaptor, 如果函数返回真 则是要的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_my_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>() <span class="comment">// 拿取 ownership</span></span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">filters_by_size</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">13</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sandal&quot;</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>) &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_my_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        in_my_size,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>) &#125;,</span><br><span class="line">            Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>) &#125;,</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义一个 iterable</p>
</blockquote>
<p><code>src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calling_next_directly</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">using_other_iterator_trait_methods</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">                                 .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">                                 .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                 .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zip</code> 只处理4个pair,因为任何pair中有None的话，zip会返回None</p>
<p>上面都会调用next()</p>
<h2 id="Improving-Our-I-x2F-O-Project"><a href="#Improving-Our-I-x2F-O-Project" class="headerlink" title="Improving Our I&#x2F;O Project"></a>Improving Our I&#x2F;O Project</h2><p>看上面IO那一章的<code>Config::new</code>函数</p>
<p>我们使用clone,因为我们没有args的 ownership</p>
<p>修改上面那章的<code>main.rs</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/main.rs</span></span><br><span class="line"><span class="comment">+++ b/src/main.rs</span></span><br><span class="line"><span class="meta">@@ -4,9 +4,7 @@</span> use std::process;</span><br><span class="line"> use minigrep::Config;</span><br><span class="line"> </span><br><span class="line"> fn main() &#123;</span><br><span class="line"><span class="deletion">-    let args: Vec&lt;String&gt; = env::args().collect();</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-    let config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span></span><br><span class="line"><span class="addition">+    let config = Config::new(env::args()).unwrap_or_else(|err| &#123;</span></span><br><span class="line">         eprintln!(&quot;Problem parsing arguments: &#123;&#125;&quot;, err);</span><br><span class="line">         process::exit(1);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<p>这里的<code>env::args</code>我们传递的是<code>iterator</code>的<code>ownership</code></p>
<p>对应 把之前的代码改简洁</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/lib.rs</span></span><br><span class="line"><span class="comment">+++ b/src/lib.rs</span></span><br><span class="line"><span class="meta">@@ -9,12 +9,18 @@</span> pub struct Config &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> impl Config &#123;</span><br><span class="line"><span class="deletion">-    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="deletion">-        if args.len() &lt; 3 &#123;</span></span><br><span class="line"><span class="deletion">-            return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line"><span class="deletion">-        &#125;</span></span><br><span class="line"><span class="deletion">-        let query = args[1].clone();</span></span><br><span class="line"><span class="deletion">-        let filename = args[2].clone();</span></span><br><span class="line"><span class="addition">+    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123;</span></span><br><span class="line"><span class="addition">+        args.next(); //第一个是 这个程序名字 忽略它</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        let query = match args.next() &#123;</span></span><br><span class="line"><span class="addition">+            Some(arg) =&gt; arg,</span></span><br><span class="line"><span class="addition">+            None =&gt; return Err(&quot;Didn&#x27;t get a query string&quot;),</span></span><br><span class="line"><span class="addition">+        &#125;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        let filename = match args.next() &#123;</span></span><br><span class="line"><span class="addition">+            Some(arg) =&gt; arg,</span></span><br><span class="line"><span class="addition">+            None =&gt; return Err(&quot;Didn&#x27;t get a file name&quot;),</span></span><br><span class="line"><span class="addition">+        &#125;;</span></span><br><span class="line"> </span><br><span class="line">         let case_insensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -40,13 +46,9 @@</span> pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> pub fn search&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line"><span class="deletion">-    let mut results = Vec::new();</span></span><br><span class="line"><span class="deletion">-    for line in contents.lines() &#123;</span></span><br><span class="line"><span class="deletion">-        if line.contains(query) &#123;</span></span><br><span class="line"><span class="deletion">-            results.push(line);</span></span><br><span class="line"><span class="deletion">-        &#125;</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line"><span class="deletion">-    results</span></span><br><span class="line"><span class="addition">+    contents.lines()</span></span><br><span class="line"><span class="addition">+        .filter(|line| line.contains(query))</span></span><br><span class="line"><span class="addition">+        .collect()</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> pub fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>新的<code>search</code>代码 把老生长谈的方法变成函数</p>
<h2 id="Comparing-Performance-Loops-vs-Iterators"><a href="#Comparing-Performance-Loops-vs-Iterators" class="headerlink" title="Comparing Performance: Loops vs. Iterators"></a>Comparing Performance: Loops vs. Iterators</h2><p>竟然还有性能比较，大概</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)</span><br><span class="line">test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)</span><br></pre></td></tr></table></figure>

<p>这就意味着 iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself. 牛逼了</p>
<p>Iterators are one of Rust’s zero-cost abstractions, by which we mean using the abstraction imposes no additional runtime overhead</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p>
</blockquote>
<p>下面是一个音频处理代码的部分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">buffer</span>: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">coefficients</span>: [<span class="type">i64</span>; <span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">qlp_shift</span>: <span class="type">i16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">12</span>..buffer.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">prediction</span> = coefficients.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                               .<span class="title function_ invoke__">zip</span>(&amp;buffer[i - <span class="number">12</span>..i])</span><br><span class="line">                               .<span class="title function_ invoke__">map</span>(|(&amp;c, &amp;s)| c * s <span class="keyword">as</span> <span class="type">i64</span>)</span><br><span class="line">                               .sum::&lt;<span class="type">i64</span>&gt;() &gt;&gt; qlp_shift;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">delta</span> = buffer[i];</span><br><span class="line">  buffer[i] = prediction <span class="keyword">as</span> <span class="type">i32</span> + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了计算<code>prediction</code>的值，遍历<code>coefficients</code>的12个值,和buffer的每个值构成<code>(一个coefficients,一个buffer)</code>然后两两相乘，求和，最后位移一下。</p>
<p>Rust编译器会把它们编译成 和手写实现 相类似的 <code>汇编代码</code>，这里甚至把循环12次进行<code>循环展开</code></p>
<h1 id="More-About-Cargo-and-Crates-io"><a href="#More-About-Cargo-and-Crates-io" class="headerlink" title="More About Cargo and Crates.io"></a>More About Cargo and Crates.io</h1><ul>
<li>Customize your build through release profiles</li>
<li>Publish libraries on <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a></li>
<li>Organize large projects with workspaces</li>
<li>Install binaries from crates.io</li>
<li>Extend Cargo using custom commands</li>
</ul>
<p>更多文档 请看 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/">这里</a></p>
<h2 id="Customizing-Builds-with-Release-Profiles"><a href="#Customizing-Builds-with-Release-Profiles" class="headerlink" title="Customizing Builds with Release Profiles"></a>Customizing Builds with Release Profiles</h2><p><code>release profiles</code>是预定义，可定制</p>
<p><code>Cargo</code>有两个主要的配置</p>
<p><code>dev</code>:<code>cargo build</code></p>
<p><code>release</code>:<code>cargo build --release</code></p>
<p>如果<code>Cargo.toml</code>没有任何<code>[profile.*]</code> 则采用默认配置</p>
<p>如果在<code>Cargo.toml</code>中配置，则是写了多少就覆盖多少默认的</p>
<p>如</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="Publishing-a-Crate-to-Crates-io"><a href="#Publishing-a-Crate-to-Crates-io" class="headerlink" title="Publishing a Crate to Crates.io"></a>Publishing a Crate to Crates.io</h2><p><code>crates.io</code> 可以用github账号登陆</p>
<p>这是一个可以上传也可以下载别人共享的</p>
<ul>
<li>准确的文档描述你的packages</li>
</ul>
<p>Rust 如果用<code>///</code>来写注释，可以自动生成HTML文档 例如</p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// &lt;三个` hexo next 的解析不支持...会和上面的配对&gt;</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = &lt;这里写你的包名&gt;::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// &lt;三个` hexo next 的解析不支持...会和上面的配对&gt;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在本地<code>cargo doc --open</code>来查看</p>
<p>所以这是markdown语法!?</p>
<p>标题 有</p>
<p><code># Examples</code></p>
<p><code># Panics</code>:提示用户什么时候可能触发</p>
<p><code># Errors</code>:例如返回的Result，那么有错误类型的描述</p>
<p><code># safety</code>: 解释为什么这个方法是<code>unsafe</code>的 &#x2F;&#x2F;19章节</p>
<p>running <code>cargo test</code> will run the code examples in your documentation as tests!!!!!!!!!!!!!!!!!??????????????</p>
<p>试了一下有点意思啊，这么溜吗,这解决了,有可能只改了代码和测试，但忘记改文档的问题</p>
<p>We typically use these doc comments inside the crate root file, 用<code>//!</code> 做根描述</p>
<p>你在实现模块的层级架构和用户使用期望的层级架构是有差异的，你编写可能更考虑分化，可迭代性等等多层级，而用户可能只希望好用。</p>
<p>如果你直接<code>cargo doc</code> 对于你层级内的东西，用户需要反复点击才能找到</p>
<p>要解决这个问题，你可以在 <code>src/lib.rs</code>上 加</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> 层级::层级::要<span class="keyword">pub</span>的;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> 层级::层级::要<span class="keyword">pub</span>的;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> 层级::层级::要<span class="keyword">pub</span>的;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>账号</p>
</blockquote>
<p>github登陆</p>
<p><code>https://crates.io/me</code>创建<code>token</code>,然后根据它的提示，就可以在命令行登陆了,注意保密！</p>
<blockquote>
<p>发布准备</p>
</blockquote>
<p><code>Cargo.toml</code>配置名称等，注意<code>crates.io</code>上是先到先得 &#x2F;&#x2F;个人感觉这样设计并不够好，还是<code>用户/仓库名</code>的那种体验更好，复议</p>
<p>license 也可以用OR 连接,一个完整的大概像这样</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！！！一旦发布不能被删除，是永久的，只能有版本更新</strong>: 使用<code>cargo publish</code>来发布</p>
<blockquote>
<p>关于版本号 <a target="_blank" rel="noopener" href="https://semver.org/">https://semver.org/</a></p>
</blockquote>
<p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>
<ul>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards-compatible manner, and</li>
<li>PATCH version when you make backwards-compatible bug fixes.</li>
</ul>
<p>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.</p>
<p>撤回版本<code>cargo yank --vers 1.0.1</code>:意义 并没有删除，但是新的没有指定该版本的不会依赖该版本，但别人已经指定lock该版本的，依然可以下载。</p>
<p><code>cargo yank --vers 1.0.1 --undo</code> 撤销 撤回</p>
<h2 id="Cargo-Workspaces"><a href="#Cargo-Workspaces" class="headerlink" title="Cargo Workspaces"></a>Cargo Workspaces</h2><p>cargo提供一个Workspaces,来管理多个相互关联的开发包</p>
<p><code>workspace = package*</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir workspacedemo &amp;&amp; cd workspacedemo</span><br></pre></td></tr></table></figure>

<p>建立文件<code>Cargo.toml</code>并写入</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add-one&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new adder</span><br><span class="line">cargo new add-one --lib</span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── adder</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">├── add-one</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件<code>add-one/src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件<code>adder/Cargo.toml</code>的<code>[dependencies]</code>字段</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">add-one</span> = &#123; path = <span class="string">&quot;../add-one&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>adder/src/main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> add_one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125; plus one is &#123;&#125;!&quot;</span>, num, add_one::<span class="title function_ invoke__">add_one</span>(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><code>cargo build</code></p>
<p><code>cargo run -p adder</code></p>
<p>你会发现，只有workspace根地方才有lock，保证了哥哥package之间用的相同的依赖版本</p>
<p>对于外部包来说，例如rand</p>
<p>我们在<code>add-one/Cargo.toml</code>中加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line"></span><br><span class="line">rand = &quot;0.3.14&quot;</span><br></pre></td></tr></table></figure>

<p>但是在adder中并不能使用，如果要使用，需要在<code>adder</code>的<code>Cargo.toml</code>中也加上 rand的依赖</p>
<p>单元测试和之前一样，区别是，我们可以 用<code>cargo test -p add-one</code>这样来指定具体的packages</p>
<p>workspace发布，你需要进入每个package目录单独<code>cargo publish</code>发布，没有<code>--all</code>或<code>-p</code>参数</p>
<h2 id="Installing-Binaries-from-Crates-io-with-cargo-install"><a href="#Installing-Binaries-from-Crates-io-with-cargo-install" class="headerlink" title="Installing Binaries from Crates.io with cargo install"></a>Installing Binaries from Crates.io with cargo install</h2><p>你只能install 有 二进制targets的 也就是<code>src/main.rs</code>的</p>
<p>一般来说README文件中会说清 是lib还是bin</p>
<p>所有<code>cargo install</code>的二进制默认放在<code>$HOME/.cargo/bin</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span> ~/.cargo/bin/</span></span><br><span class="line">cargo         cargo-fmt   clippy-driver  rustc    rustfmt   rustlings  rustup</span><br><span class="line">cargo-clippy  cargo-miri  rls            rustdoc  rust-gdb  rust-lldb</span><br></pre></td></tr></table></figure>

<p>我们用<code>ripgrep</code>举例</p>
<p>首先<code>cargo install ripgrep</code></p>
<p>然后就可以<code>rg --help</code>使用了</p>
<h2 id="Extending-Cargo-with-Custom-Commands"><a href="#Extending-Cargo-with-Custom-Commands" class="headerlink" title="Extending Cargo with Custom Commands"></a>Extending Cargo with Custom Commands</h2><p>如果，你的<code>$PATH</code>中存在某个<code>cargo-something</code>那么你可以用<code>cargo something</code> 命令</p>
<p>你甚至可以用<code>cargo ---list</code>查看</p>
<h1 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h1><p>好熟悉的名字，玩过C++的都知道 c++一组 smart pointer,以前用的时候觉得还是很香的</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2019">https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2019</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/book/intro/smart_pointers">https://en.cppreference.com/book/intro/smart_pointers</a></p>
<hr>
<p>references are pointers that only borrow data; </p>
<p>作为对比大多数情况下, smart pointers own the data they point to.</p>
<p>我们已经讲过的<code>String</code>和<code>Vec&lt;T&gt;</code>就是 smart pointers,因为它们有用一些内存，并且允许你 操作它,</p>
<p>除此外它们也有metadata,以及一些额外的功能，如String 会保证始终是一个有效的 <code>UTF-8</code>;</p>
<p>职能指针通常用结构体实现，和普通 struct相比，它们实现了<code>Deref</code>和<code>Drop</code> traits</p>
<p><code>Deref</code> trait 允许一个 smart pointer 结构体 像一个 reference一样使用</p>
<p><code>Drop</code> trait 允许你自己设计当一个该smart pointers 的 instance 除了scope时的行为</p>
<p>本章 只会 讲解 部分 常用的 标准库里的 智能指针:</p>
<ul>
<li><code>Box&lt;T&gt;</code>: 在 堆上 allocating values</li>
<li><code>Rc&lt;T&gt;</code>, 一个引用计数，允许 多个ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;,</code> a type that enforces the borrowing rules 在运行时 而不是 编译时</li>
</ul>
<p>此外，本章还会有 <code>interior mutability</code></p>
<p>也会讨论<code>reference cycles</code> 是如何 内存泄漏 和 如何防止</p>
<h2 id="Using-Box-to-Point-to-Data-on-the-Heap"><a href="#Using-Box-to-Point-to-Data-on-the-Heap" class="headerlink" title="Using Box to Point to Data on the Heap"></a>Using Box to Point to Data on the Heap</h2><p>用<code>Box&lt;T&gt;</code></p>
<p>最直接的 smart pointer,让你可以在堆上保存值，而不是栈上</p>
<p>较常使用场景:</p>
<ul>
<li>编译时 不知道大小，比如递归类型</li>
<li>想transfer ownership大量的数据，但要确保数据不会被拷贝,比如为了性能</li>
<li>当你 own a value 且你只关心这个value的type实现了一个特定的trait 而不在意 是一个特定的 type， 看作trait object</li>
</ul>
<p>香不香</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>); <span class="comment">// 虽然一般不会这样写没啥意义，但这样可以示例</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A <code>cons list</code> is a data structure that comes from the <code>Lisp</code> programming language and its dialects</p>
<p>cons &#x3D; ‘construct’</p>
<p><code>to cons x onto y</code> 意味着形成? (x,y)</p>
<p>以下代码无 ,但是 尝试一个递归的定义效</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>List</code> 类型来存储<code>1,2,3</code></p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们还没有解决上面递归定义的问题，会报错<code>recursive type has infinite size</code></p>
<p>…c玩得熟的话，这大概就是<code>struct里放同一个struct</code>和<code>struct里放 同一个struct指针</code>的区别</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl15-01.svg" alt="Cons list Cons"></p>
<p><code>Box&lt;T&gt;</code> needs: a pointer’s size, 不会因为指向不同的数据改变所需要的空间大小</p>
<p>以下是可以运行的</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>,</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,</span><br><span class="line">                <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://doc.rust-lang.org/book/img/trpl15-02.svg" alt="cons box list"></p>
<h2 id="Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait"><a href="#Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait" class="headerlink" title="Treating Smart Pointers Like Regular References with the Deref Trait"></a>Treating Smart Pointers Like Regular References with the Deref Trait</h2><p>实现了<code>Deref</code>trait 可以让你自定义 <code>dereference operator</code>的行为</p>
<p>然后你就可以像使用引用一样使用 相应结构体</p>
<p>先看<code>deref coercion</code> feature</p>
<p><strong>注意</strong>以下示例 只关注了 <code>Deref</code>trait的实现，</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望下面代码能运行成功</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T; <span class="comment">// 这里为了让`Deref`能使用 MyBox&lt;T&gt; -&gt; T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 会把上面<code>*y</code>实际看作<code>*(y.deref())</code></p>
<h3 id="Implicit-Deref-Coercions-with-Functions-and-Methods"><a href="#Implicit-Deref-Coercions-with-Functions-and-Methods" class="headerlink" title="Implicit Deref Coercions with Functions and Methods"></a>Implicit Deref Coercions with Functions and Methods</h3><p>像上面的 我们可以这样使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m); <span class="comment">// 通过Deref, &amp;MyBox&lt;String&gt; -&gt; &amp;String -&gt; &amp;str</span></span><br><span class="line">    <span class="comment">// 如果没有 Rust的这个帮助，我们要`&amp;(*m)[..]`这样写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三种情况会转化</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>类似如果你希望 <code>*</code>操作 是 <code>immutable references</code>,那么用<code>DerefMut</code>替代<code>Deref</code></p>
<p>第三种 是一个trick，吧 mutable 转换成 immutable, （但反过来不行）</p>
<h2 id="Running-Code-on-Cleanup-with-the-Drop-Trait"><a href="#Running-Code-on-Cleanup-with-the-Drop-Trait" class="headerlink" title="Running Code on Cleanup with the Drop Trait"></a>Running Code on Cleanup with the Drop Trait</h2><p><code>Drop</code> trait : lets you customize what happens when a value is about to go out of scope.</p>
<p>例如，<code>Box&lt;T&gt;</code>自定义的<code>Drop</code>行为是 deallcate box 指向的堆上的space</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct CustomSmartPointer &#123;</span><br><span class="line">    data: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for CustomSmartPointer &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        println!(&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;, self.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = CustomSmartPointer &#123; data: String::from(&quot;my stuff&quot;) &#125;;</span><br><span class="line">    let d = CustomSmartPointer &#123; data: String::from(&quot;other stuff&quot;) &#125;;</span><br><span class="line">    println!(&quot;CustomSmartPointers created.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CustomSmartPointers created.</span><br><span class="line">Dropping CustomSmartPointer with data `other stuff`!</span><br><span class="line">Dropping CustomSmartPointer with data `my stuff`!</span><br></pre></td></tr></table></figure>

<p>Variables are dropped in the reverse order of their creation.</p>
<p>如果我们希望 早一些 释放，我们并不能直接调用<code>.drop()</code>explicit destructor calls not allowed，因为这样Rust依然会 自动调用<code>drop</code>，可能<code>double free</code></p>
<p>我们只能调用<code>std::mem::drop</code>来早些释放，如(锁的控制)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123; data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;some data&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明了 内存你依然管不了？只能说 影响影响 释放时机</p>
<h2 id="Rc-the-Reference-Counted-Smart-Pointer"><a href="#Rc-the-Reference-Counted-Smart-Pointer" class="headerlink" title="Rc, the Reference Counted Smart Pointer"></a>Rc, the Reference Counted Smart Pointer</h2><p>计数智能指针</p>
<p>比如图，一个点可能被很多指向边拥有</p>
<p>注意！ 在单线程中使用<code>Rc&lt;T&gt;</code>如果要多线程的 请看下一章节</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl15-03.svg" alt="rc"></p>
<p>首先 Box+Cons会挂掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Cons(5,</span><br><span class="line">        Box::new(Cons(10,</span><br><span class="line">            Box::new(Nil))));</span><br><span class="line">    let b = Cons(3, Box::new(a)); // 这里move了a 而不是Copy</span><br><span class="line">    let c = Cons(4, Box::new(a)); // 这里便不可用了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Rc</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)); <span class="comment">// 计数+1 而不是深拷贝 a.clone()</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a)); <span class="comment">// 计数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Rc::strong_count</code>查看Rc计数的变化</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的遗憾就是，还没能 让多个都是mutable，但有时，多个拥有者都能mutable也是很有用的。将在下一节提到</p>
<h2 id="RefCell-and-the-Interior-Mutability-Pattern"><a href="#RefCell-and-the-Interior-Mutability-Pattern" class="headerlink" title="RefCell and the Interior Mutability Pattern"></a>RefCell and the Interior Mutability Pattern</h2><p><code>RefCell&lt;T&gt;</code> 和 <code>interior Mutability Pattern</code></p>
<p><code>Interior mutability</code>的实际模式，是为了让你能改变引用不可变的内部数据</p>
<p>用的是<code>unsafe</code>代码来 bend 一些Rust 规则,达到 外部 不可变，内部可变</p>
<p>represents single ownership over the data it holds</p>
<p>回顾第4章 的ownership</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>然后，我们上面的 Box 会在 编译时 检查borrowing规则, &#x2F;&#x2F; 因为这种 会有更小的运行时消耗，因此 Rust默认大多是这样</p>
<p>然后，我们上面的 RefCell 会在 运行时 检查borrowing规则 &#x2F;&#x2F; 例如停机问题咯，并不是所有都能，</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code> allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is immutable.</li>
</ul>
<p>Interior  Mutability的一个使用场景: Mock Objects</p>
<p><code>test double</code></p>
<p>如下<code>cargo test</code>会报错</p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Messenger &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个方案是 加一堆mut</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/lib.rs</span></span><br><span class="line"><span class="comment">+++ b/src/lib.rs</span></span><br><span class="line"><span class="meta">@@ -1,16 +1,16 @@</span></span><br><span class="line"> pub trait Messenger &#123;</span><br><span class="line"><span class="deletion">-    fn send(&amp;self, msg: &amp;str);</span></span><br><span class="line"><span class="addition">+    fn send(&amp;mut self, msg: &amp;str);</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> pub struct LimitTracker&lt;&#x27;a, T: Messenger&gt; &#123;</span><br><span class="line"><span class="deletion">-    messenger: &amp;&#x27;a T,</span></span><br><span class="line"><span class="addition">+    messenger: &amp;&#x27;a mut T,</span></span><br><span class="line">     value: usize,</span><br><span class="line">     max: usize,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> impl&lt;&#x27;a, T&gt; LimitTracker&lt;&#x27;a, T&gt;</span><br><span class="line">     where T: Messenger &#123;</span><br><span class="line"><span class="deletion">-    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; &#123;</span></span><br><span class="line"><span class="addition">+    pub fn new(messenger: &amp;mut T, max: usize) -&gt; LimitTracker&lt;T&gt; &#123;</span></span><br><span class="line">         LimitTracker &#123;</span><br><span class="line">             messenger,</span><br><span class="line">             value: 0,</span><br><span class="line"><span class="meta">@@ -48,15 +48,15 @@</span> mod tests &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     impl Messenger for MockMessenger &#123;</span><br><span class="line"><span class="deletion">-        fn send(&amp;self, message: &amp;str) &#123;</span></span><br><span class="line"><span class="addition">+        fn send(&amp;mut self, message: &amp;str) &#123;</span></span><br><span class="line">             self.sent_messages.push(String::from(message));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     #[test]</span><br><span class="line">     fn it_sends_an_over_75_percent_warning_message() &#123;</span><br><span class="line"><span class="deletion">-        let mock_messenger = MockMessenger::new();</span></span><br><span class="line"><span class="deletion">-        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);</span></span><br><span class="line"><span class="addition">+        let mut mock_messenger = MockMessenger::new();</span></span><br><span class="line"><span class="addition">+        let mut limit_tracker = LimitTracker::new(&amp;mut mock_messenger, 100);</span></span><br><span class="line"> </span><br><span class="line">         limit_tracker.set_value(80);</span><br></pre></td></tr></table></figure>

<p>而我们实际 只是希望self中的某一个子部分是可变的，我们用<code>RefCell&lt;T&gt;</code>来搞,改动如下</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/lib.rs</span></span><br><span class="line"><span class="comment">+++ b/src/lib.rs</span></span><br><span class="line"><span class="meta">@@ -36,20 +36,21 @@</span> impl&lt;&#x27;a, T&gt; LimitTracker&lt;&#x27;a, T&gt;</span><br><span class="line"> #[cfg(test)]</span><br><span class="line"> mod tests &#123;</span><br><span class="line">     use super::*;</span><br><span class="line"><span class="addition">+    use std::cell::RefCell;</span></span><br><span class="line"> </span><br><span class="line">     struct MockMessenger &#123;</span><br><span class="line"><span class="deletion">-        sent_messages: Vec&lt;String&gt;,</span></span><br><span class="line"><span class="addition">+        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     impl MockMessenger &#123;</span><br><span class="line">         fn new() -&gt; MockMessenger &#123;</span><br><span class="line"><span class="deletion">-            MockMessenger &#123; sent_messages: vec![] &#125;</span></span><br><span class="line"><span class="addition">+            MockMessenger &#123; sent_messages: RefCell::new(vec![]) &#125;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     impl Messenger for MockMessenger &#123;</span><br><span class="line">         fn send(&amp;self, message: &amp;str) &#123;</span><br><span class="line"><span class="deletion">-            self.sent_messages.push(String::from(message));</span></span><br><span class="line"><span class="addition">+            self.sent_messages.borrow_mut().push(String::from(message));</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -60,6 +61,6 @@</span> mod tests &#123;</span><br><span class="line"> </span><br><span class="line">         limit_tracker.set_value(80);</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        assert_eq!(mock_messenger.sent_messages.len(), 1);</span></span><br><span class="line"><span class="addition">+        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>相对于 我们 之前的 <code>&amp;</code>和<code>&amp;mut</code>,<code>RefCell&lt;T&gt;</code>的对应的方法是</p>
<p><code>borrow</code> 和 <code>borrow_mut</code> 调用时 会引起 计数变化</p>
<p>分别返回<code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>类型</p>
<p>同理 基本的borrow标准还是不能违反， 如下面这样就会挂掉</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">one_borrow</span> = <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">two_borrow</span> = <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line"></span><br><span class="line">        one_borrow.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        two_borrow.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但不太棒的是 这个错误因为是RefCell给出的，它是运行时，所以你可能不一定检测到发生了这个问题，</p>
<p>一个推荐的方法是 <code>Rc&lt;T&gt;</code> + <code>RefCell&lt;T&gt;</code>同时使用</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;), <span class="comment">// 这里 同时使用</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">6</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">10</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span><br><span class="line">b after = Cons(RefCell &#123; value: 6 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br><span class="line">c after = Cons(RefCell &#123; value: 10 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br></pre></td></tr></table></figure>

<p>标准库里还有<code>Cell&lt;T&gt;</code>,<code>Mutex&lt;T&gt;</code></p>
<h2 id="Reference-Cycles-Can-Leak-Memory"><a href="#Reference-Cycles-Can-Leak-Memory" class="headerlink" title="Reference Cycles Can Leak Memory"></a>Reference Cycles Can Leak Memory</h2><p>循环 引用，比如图</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item = &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment the next line to see that we have a cycle;</span></span><br><span class="line">    <span class="comment">// it will overflow the stack</span></span><br><span class="line">    <span class="comment">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a和b的<code>strong_count</code>计数都是2</p>
<p><img data-src="https://doc.rust-lang.org/book/img/trpl15-04.svg" alt="cycle"></p>
<p><code>Creating a reference cycle would be a logic bug</code>???之前有实践过用index来代替指针，实现可以数据库保存读取,但是 我在实现如一些图论算法的时候，感觉用指针来写会体验更好?虽然感觉这种手工index能对 内存泄露解决，但是感觉是把本来指针就能提供的功能弃用了</p>
<p>应该automated tests, code reviews, and other software development practices to minimize.尽量减少循环引用</p>
<p>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want Cons variants to own their list, so reorganizing the data structure isn’t possible. Let’s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</p>
<p>把 <code>Rc&lt;T&gt;</code>改成<code>Weak&lt;T&gt;</code></p>
<p>之前是调用<code>Rc::clone</code>，会增加<code>strong_count</code></p>
<p>现在<code>Rc::downgrade</code>会创建一个<code>Weak&lt;T&gt;</code>会使得<code>weak_count</code>的计数加1,并不表示一个<code>ownership relationship</code></p>
<p>只有在<code>strong_count</code>变为0时就会clean up了，不会在意<code>weak_count</code></p>
<p>所以 你在操作一个<code>weak_count</code>指向的时候，应该检查它指向的是否还存在，通过<code>upgrade</code>在一个<code>Weak&lt;T&gt;</code>实例上调用，返回<code>Option&lt;T&gt;</code>，如果没有被Drop它会返回一个<code>Some</code>，否则是个None</p>
<blockquote>
<p>样例代码 建立一个树</p>
</blockquote>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想法类似的话，感觉文件系统里的 软链接和硬链接 很相似</p>
<h1 id="Fearless-Concurrency"><a href="#Fearless-Concurrency" class="headerlink" title="Fearless Concurrency"></a>Fearless Concurrency</h1><p>让并行程序安全和高效是Rust的另一个主要goals</p>
<p>rust通过手段让很多错误变成 编译时错误而不是运行时错误</p>
<p>We’ve nicknamed this aspect of Rust fearless concurrency</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time 如何写并行</li>
<li>Message-passing concurrency, where channels send messages between threads 消息传递</li>
<li>Shared-state concurrency, where multiple threads have access to some piece of data 共享数据</li>
<li>The Sync and Send traits, which extend Rust’s concurrency guarantees to user-defined types as well as types provided by the standard library 两个 trait 保证 用户定义的types</li>
</ul>
<h2 id="Using-Threads-to-Run-Code-Simultaneously"><a href="#Using-Threads-to-Run-Code-Simultaneously" class="headerlink" title="Using Threads to Run Code Simultaneously"></a>Using Threads to Run Code Simultaneously</h2><p>有些语言是 调用OS的thread ，1 operating system thread : 1 language thread.</p>
<p>有的语言是 M:N 的线程模型</p>
<p>Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</p>
<p>有的语言会用运行代价来换取更多feature，但Rust定位是<code>low-level</code>的 只提供1：1的线程实现</p>
<p>我们调用<code>thread::spawn</code>并且传递一个 闭包</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thread::sleep</code>允许 线程 让出一小段时间不执行,其它线程可能紧接着这个时候开始执行，也可能不 </p>
<blockquote>
<p>Waiting for All Threads to Finish Using <code>join</code> Handles</p>
</blockquote>
<p>c++也是有thread::join，重名大法好，不用记多个</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 会等待线程结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>move</code> closure 经常伴随 thread::spawn 因为它允许 在不同的线程之间使用数据</p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123; <span class="comment">// 被move到线程里了</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程 不再有v</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Using-Message-Passing-to-Transfer-Data-Between-Threads"><a href="#Using-Message-Passing-to-Transfer-Data-Between-Threads" class="headerlink" title="Using Message Passing to Transfer Data Between Threads"></a>Using Message Passing to Transfer Data Between Threads</h2><p>奶了一口 Golang</p>
<p>Here’s the idea in a slogan from <a target="_blank" rel="noopener" href="http://golang.org/doc/effective_go.html">the Go language documentation</a>: “Do not communicate by sharing memory; instead, share memory by communicating.”</p>
<p><code>mpsc</code> stands for <code>multiple producer, single consumer</code></p>
<p><code>mpsc::channel</code>返回<code>tuple = (sending end, receiving end)</code></p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受端 方法有<code>recv</code>和<code>try_recv</code></p>
<p><code>recv</code>会阻塞 返回<code>Result&lt;T,E&gt;</code> 当这个channel发送端关闭，recv会收到一个 error</p>
<p><code>recv_block</code>不会阻塞 会根据是否有 返回<code>Result&lt;T,E&gt;</code> </p>
<p>ownership 在channel间 交接:-) ,send 会 获取参数所有权，并移动这个值 归 接受者所有</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个发送者</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tx1</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx); <span class="comment">// &lt;--------------</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tx1:hi&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tx1:from&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tx1:the&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tx1:thread&quot;</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Shared-State-Concurrency"><a href="#Shared-State-Concurrency" class="headerlink" title="Shared-State Concurrency"></a>Shared-State Concurrency</h2><p>Consider this part of the slogan from the Go language documentation again: “communicate by sharing memory.”</p>
<blockquote>
<p>Using Mutexes(mutual exclusion) to Allow Access to Data from One Thread at a Time</p>
</blockquote>
<p>锁嘛&#x3D;.&#x3D;</p>
<ul>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</li>
</ul>
<p>However, thanks to Rust’s type system and ownership rules, you can’t get locking and unlocking wrong.</p>
<blockquote>
<p>The API of <code>Mutex&lt;T&gt;</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 申请锁 , 返回的是mutable reference to the data value</span></span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 智能指针自动释放 lock也会自动释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m); <span class="comment">// 释放以后可读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.lock()</code>返回一个 <code>MutexGuard</code>的智能指针，wrapped in a <code>LockResult</code></p>
<blockquote>
<p>在线程间 使用 mutex Multiple Ownership with Multiple Threads</p>
</blockquote>
<p><code>Rc&lt;T&gt;</code> is not safe to share across threads,改变reference 计数，它不是一个线程安全的</p>
<p>Atomic Reference Counting with <code>Arc&lt;T&gt;</code></p>
<p>因为 原子实现有性能代价，所以不是所有库和方法都是原子的</p>
<p><code>Arc&lt;T&gt;</code>和<code>Rc&lt;T&gt;</code>有相同的API</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// immutable 但我们 可以获得一个它内部的 mutable</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)); <span class="comment">// 相对于Rc 这是原子的,如果用Rc 编译器会提示你不安全</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123; <span class="comment">// move 语义 只移动了 Arc 的</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 主线程 还能访问counter 因为没有被 move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RefCell&lt;T&gt;</code>&#x2F;<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>&#x2F;<code>Arc&lt;T&gt;</code>的相似之处</p>
<p><code>Mutex&lt;T&gt;</code> provides interior mutability, as the <code>Cell</code> family does</p>
<p>之前 我们用 Rc+RefCell来 完成 interior mutablility，现在可以用Mutex+Arc来实现多线程的</p>
<p>但比如死锁 并没有办法完美检测, 不过Rust 用了其它语言用的减轻 deadlock 的策略 来 进行有效的信息提醒</p>
<h2 id="Extensible-Concurrency-with-the-Sync-and-Send-Traits"><a href="#Extensible-Concurrency-with-the-Sync-and-Send-Traits" class="headerlink" title="Extensible Concurrency with the Sync and Send Traits"></a>Extensible Concurrency with the Sync and Send Traits</h2><p>语言中 内嵌了两个 并行概念: the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code></p>
<p><code>Send</code>允许 thread之间 传递Ownership</p>
<p><code>Send</code> marker trait,基本上每个Rust都实现了Send，但有一些例外，包括<code>Rc&lt;T&gt;</code></p>
<p>会报错<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code></p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as well. !!!!</p>
<p>这就有意思了，自动 mark为<code>Send</code></p>
<p>有<code>Sync</code> marker trait，意味着这个类型 被多线程引用是安全的</p>
<p>any type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>,意味这它的引用被发送到另一个 线程是安全的</p>
<p>类似上面 也有基础类型是<code>Sync</code>，以及由<code>Sync</code>组成的依然是<code>Sync</code></p>
<p>the family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code></p>
<h3 id="Implementing-Send-and-Sync-Manually-Is-Unsafe"><a href="#Implementing-Send-and-Sync-Manually-Is-Unsafe" class="headerlink" title="Implementing Send and Sync Manually Is Unsafe"></a>Implementing Send and Sync Manually Is Unsafe</h3><p><strong>不要</strong>自己实现，应该遵循 基础类型是，然后 符合类型如果所有子类型是，那么即是的 规则</p>
<h1 id="Object-Oriented-Programming-Features-of-Rust"><a href="#Object-Oriented-Programming-Features-of-Rust" class="headerlink" title="Object Oriented Programming Features of Rust"></a>Object Oriented Programming Features of Rust</h1><p>该来的 总是会来了 OOP还是来了</p>
<h2 id="Characteristics-of-Object-Oriented-Languages"><a href="#Characteristics-of-Object-Oriented-Languages" class="headerlink" title="Characteristics of Object-Oriented Languages"></a>Characteristics of Object-Oriented Languages</h2><p>OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance.</p>
<blockquote>
<p>Encapsulation that Hides Implementation Details</p>
</blockquote>
<p>之前章节就讲过，rust通过pub来对是否可被外部访问进行控制,并且是对任意的子field可以进行控制</p>
<p>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement</p>
<blockquote>
<p>Inheritance as a Type System and as Code Sharing</p>
</blockquote>
<p>If a language must have inheritance to be an object-oriented language, then Rust is <strong>not</strong> one</p>
<p>没有办法定义一个 能够继承父struct 字段和方法实现的 struct</p>
<p>如果你希望实现继承，那么你可以根据你的需求来进行选择，要使用 inheritance 有两个主要的原因</p>
<ol>
<li>重用代码: 你可以用default trait method implementations instead,比如某trait有默认实现的方法</li>
<li>子类可以用父类trait 多态:</li>
</ol>
<blockquote>
<p>多态</p>
</blockquote>
<ul>
<li><p>To many people, polymorphism is synonymous with inheritance. But it’s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</p>
</li>
<li><p>Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called <code>bounded parametric polymorphism</code>.</p>
</li>
</ul>
<p>最近 inheritance 开始 在很多语言的设计方案中，不再受到欢迎，因为它有共享的多余真实需要的代码的风险，甚至让子类中一些方法是无效的</p>
<p>Rust采用了 trait objects instead of inheritance</p>
<h2 id="Using-Trait-Objects-That-Allow-for-Values-of-Different-Types"><a href="#Using-Trait-Objects-That-Allow-for-Values-of-Different-Types" class="headerlink" title="Using Trait Objects That Allow for Values of Different Types"></a>Using Trait Objects That Allow for Values of Different Types</h2><p>定义 通用行为的trait</p>
<p><code>src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 用泛型 相比, 下面一次只能 替代一个具体类型，而trait对象 允许 运行时 多种类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button&#x2F;SelectBox的实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a select box</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123; <span class="comment">// 在这个位置检查 类型是否符合Trait</span></span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Maybe&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终 我们的两个文件</p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::&#123;Draw, Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a select box</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Maybe&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cargo run</code>运行不报错</p>
<p>下面 我们把<code>lib.rs</code>中的 实现换成 trait bound ,会报错</p>
<p><code>expected struct </code>SelectBox<code>, found struct </code>gui::Button&#96;&#96;</p>
<p>说明了 <code>trait bound</code> 只能一种类型,而 <code>trait objects</code>只会</p>
<p>trait动态分发,运行时确定要调用 什么方法,因为编译器并不知道 具体哪个 类型的实例会调用</p>
<p>at runtime, Rust uses the pointers inside the trait object to know which method to call</p>
<p>代价 是 运行时分析，以及 不能编译时优化,得到的是flexibility</p>
<p> A trait is <code>object safe</code> if all the methods defined in the trait have the following properties:</p>
<ul>
<li>The return type isn’t <code>Self</code>.</li>
<li>There are no generic type parameters</li>
</ul>
<p>但你不能像上面<code>dyn Draw</code>那样来<code>dyn Clone</code>, 因为标准库中的Clone 不是<code>object safe</code>的</p>
<p><code>the trait </code>std::clone::Clone<code>  cannot be made into an object</code></p>
<h2 id="Implementing-an-Object-Oriented-Design-Pattern"><a href="#Implementing-an-Object-Oriented-Design-Pattern" class="headerlink" title="Implementing an Object-Oriented Design Pattern"></a>Implementing an Object-Oriented Design Pattern</h2><p>??????….</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后对Draft分别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">XXX</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="comment">/*或者其它方法*/</span> <span class="title function_ invoke__">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DraftPost</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> DraftPost &#123;</span><br><span class="line">        DraftPost &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">DraftPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_text</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">push_str</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PendingReviewPost &#123;</span><br><span class="line">        PendingReviewPost &#123;</span><br><span class="line">            content: <span class="keyword">self</span>.content,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PendingReviewPost</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PendingReviewPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Post &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            content: <span class="keyword">self</span>.content,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Draft</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Draft</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PendingReview &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PendingReview</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PendingReview</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Published &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Published</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Published</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        &amp;post.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use blog::Post;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut post = Post::new();</span><br><span class="line"></span><br><span class="line">    post.add_text(&quot;I ate a salad for lunch today&quot;);</span><br><span class="line"></span><br><span class="line">    let post = post.request_review();</span><br><span class="line"></span><br><span class="line">    let post = post.approve();</span><br><span class="line"></span><br><span class="line">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Patterns-and-Matching"><a href="#Patterns-and-Matching" class="headerlink" title="Patterns and Matching"></a>Patterns and Matching</h1><p>A pattern consists of some combination of the following:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<h2 id="All-the-Places-Patterns-Can-Be-Used"><a href="#All-the-Places-Patterns-Can-Be-Used" class="headerlink" title="All the Places Patterns Can Be Used"></a>All the Places Patterns Can Be Used</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊的pattern <code>_</code>可以匹配任何的，但它不会binds to a variable</p>
<p><code>if let</code>一般只关心一个具体情况的,不能<code>&amp;&amp;</code>条件组合,需要条件组合，则把 组合的条件放到括号内</p>
<p><code>while let</code>可以用来循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; …</p>
<h2 id="Refutability-Whether-a-Pattern-Might-Fail-to-Match"><a href="#Refutability-Whether-a-Pattern-Might-Fail-to-Match" class="headerlink" title="Refutability: Whether a Pattern Might Fail to Match"></a>Refutability: Whether a Pattern Might Fail to Match</h2><p>分化为 refutable(只能接受一部分可能的值) 和 irrefutable(可以接受任何可能的传递值).</p>
<p>如<code>let x = 5;</code> irrefutable</p>
<p>如<code>Some(x) = a_value</code> 可能因为 传入是None而fail</p>
<p>在需要irrefutable的地方 用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_option_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果本来就是irrefutable,Rust会error</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0162]: irrefutable <span class="keyword">if</span>-<span class="keyword">let</span> <span class="variable">pattern</span></span><br><span class="line"> -<span class="punctuation">-&gt;</span> &lt;anon&gt;:<span class="number">2</span>:<span class="number">8</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> | <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span> &#123;</span><br><span class="line">  |        ^ irrefutable pattern</span><br></pre></td></tr></table></figure>

<h2 id="Pattern-Syntax"><a href="#Pattern-Syntax" class="headerlink" title="Pattern Syntax"></a>Pattern Syntax</h2><p>所有 syntax和 使用场景建议</p>
<p>字面量:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="comment">// 这个y不是上面的y=10,而是引入的新变量y</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        <span class="comment">// 如果None则上面的不会匹配</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配多个 pattern &#x2F; 匹配值范围</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配多个</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配范围</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="comment">// 1 | 2 | 3 | 4 | 5</span></span><br><span class="line">    <span class="number">1</span> ... <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one through five&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>...<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">    <span class="string">&#x27;k&#x27;</span>...<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>结构体解构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a , b 被分配</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        <span class="comment">// x 是 匹配出的临时， y:0是限制</span></span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="comment">// x:0 是限制 y是匹配出的临时变量</span></span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">        <span class="comment">// 都是临时变量</span></span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型 解构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure.&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 不同类型匹配 并 解构</span></span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,</span><br><span class="line">                x,</span><br><span class="line">                y</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Text message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,</span><br><span class="line">                r,</span><br><span class="line">                g,</span><br><span class="line">                b</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nested Structs and Enums 解构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">   <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">   <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        <span class="comment">// 内嵌结构体和枚举类型 解构</span></span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,</span><br><span class="line">                r,</span><br><span class="line">                g,</span><br><span class="line">                b</span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,</span><br><span class="line">                h,</span><br><span class="line">                s,</span><br><span class="line">                v</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合一 :<code>let ((feet, inches), Point &#123;x, y&#125;) = ((3, 10), Point &#123; x: 3, y: -10 &#125;);</code></p>
<p><code>_</code>忽略，例如 <code>fn foo( _ : i32,y : i32)</code></p>
<p>匹配时 忽略部分值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">match</span> (setting_value, new_setting_value) &#123;</span><br><span class="line">    (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        setting_value = new_setting_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);</span><br></pre></td></tr></table></figure>

<p><code>_</code>前缀 常见for里</p>
<p><strong>注意</strong>,<code>_</code>整个都是忽略掉的，所以不会有move，而<code>_</code>作为前缀，只是忽略掉使用，依然有move。如下列代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123; <span class="comment">// 被move</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"><span class="comment">// 正常运行</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_) = s &#123; <span class="comment">// 没有move</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>忽略多个<code>..</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">    z: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> origin &#123;</span><br><span class="line">    Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意的是<code>..</code>的使用需要无 <code>歧义</code></p>
<p><code>match guard</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="comment">// if x &lt; 5 是 match guard ...emmm  相当于 &amp;&amp; 条件?</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bindings: <code>@</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    <span class="comment">// 解构 匹配变量 同时 测试 范围 </span></span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>...<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>...<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Advanced-Features"><a href="#Advanced-Features" class="headerlink" title="Advanced Features"></a>Advanced Features</h1><p>下一章是个具体项目，这章讲也许有一天 你会遇到的rust内容</p>
<h2 id="Unsafe-Rust"><a href="#Unsafe-Rust" class="headerlink" title="Unsafe Rust"></a>Unsafe Rust</h2><p>以前为了 效率 有在golang里用 unsafe来写，但是 你这样做，需要的前提是你确定知道你在干什么</p>
<p>也就是 这部分的使用，rust不会再 保护，一旦你出错了，那rust也无法提醒你</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
</ul>
<p>注意的是<code>borrow checker 和其它的Rust&#39;s safety checks</code> 依然工作,你能用的unsafe只有上面4种</p>
<p>Keep <code>unsafe</code> blocks small</p>
<p>以及 建议上是把 unsafe的代码，封装成safe的安全抽象，例如一些标准库的内部实现是有unsafe</p>
<h3 id="Dereferencing-a-Raw-Pointer"><a href="#Dereferencing-a-Raw-Pointer" class="headerlink" title="Dereferencing a Raw Pointer"></a>Dereferencing a Raw Pointer</h3><p><code>raw pointers</code> in Rust</p>
<p><code>*const T</code> 和<code>*mut T</code> : 不可变<code>raw pointers</code> 和 可变<code>raw pointers</code></p>
<p>在<code>raw pointers</code>上下文中 <code>immutable</code> 意味着 不能直接被 assigned to after being dereferenced.</p>
<p>与 引用 和 smart pointers的不同</p>
<ul>
<li>可以突破之前4章的 同时多个immutable和mutable指针的限制 Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>不保证指向有效内存, Aren’t guaranteed to point to valid memory</li>
<li>可以null, Are allowed to be null</li>
<li>没有任何 自动清理 Don’t implement any automatic cleanup</li>
</ul>
<p>指针类型强转</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 可以写在 safe中</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 需要unsafe包裹</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接上地址</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Calling-an-Unsafe-Function-or-Method"><a href="#Calling-an-Unsafe-Function-or-Method" class="headerlink" title="Calling an Unsafe Function or Method"></a>Calling an Unsafe Function or Method</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;</span><br><span class="line">  <span class="comment">// 这里写不安全函数 不需要增加 unsafe块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把不安全的 操作，封装成 安全的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (a, b) = r.<span class="title function_ invoke__">split_at_mut</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<p>如何实现<code>split_at_mut</code></p>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>(); <span class="comment">// 返回一个 *mut i32 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, mid), <span class="comment">// 这也是不安全的</span></span><br><span class="line">         slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">offset</span>(mid <span class="keyword">as</span> <span class="type">isize</span>), len - mid))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Using <code>extern</code> Functions to Call External Code</p>
</blockquote>
<p>调用C代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// 遵循 &quot;C&quot;的 application binary interface，ABI</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建给其它语言用的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 no_mangle 告诉编译器不要mangle 以方便其它语言 安相同方法名调用</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This usage of extern does not require unsafe.</span></span><br></pre></td></tr></table></figure>

<h3 id="Accessing-or-Modifying-a-Mutable-Static-Variable"><a href="#Accessing-or-Modifying-a-Mutable-Static-Variable" class="headerlink" title="Accessing or Modifying a Mutable Static Variable"></a>Accessing or Modifying a Mutable Static Variable</h3><p>如果两个 线程 同时访问一个mutable 全局变量，可能引发data race</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别是，静态variables 运行时 有固定的内存地址，可以unsafe的修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>); <span class="comment">// 单线程，多线程调用可能引发data races</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-an-Unsafe-Trait"><a href="#Implementing-an-Unsafe-Trait" class="headerlink" title="Implementing an Unsafe Trait"></a>Implementing an Unsafe Trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当 你有需要时，且你能保证unsafe的代码是safe的时</p>
<h2 id="Advanced-Traits"><a href="#Advanced-Traits" class="headerlink" title="Advanced Traits"></a>Advanced Traits</h2><h3 id="Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types"><a href="#Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types" class="headerlink" title="Specifying Placeholder Types in Trait Definitions with Associated Types"></a>Specifying Placeholder Types in Trait Definitions with Associated Types</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>; <span class="comment">// 占位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;; <span class="comment">// 知道返回的是一个Item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times.</p>
<h3 id="Default-Generic-Type-Parameters-and-Operator-Overloading"><a href="#Default-Generic-Type-Parameters-and-Operator-Overloading" class="headerlink" title="Default Generic Type Parameters and Operator Overloading"></a>Default Generic Type Parameters and Operator Overloading</h3><p>Point 重载 <code>Add</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point; <span class="comment">// 指定类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">               Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数</p>
<ul>
<li>扩展类型而不破坏现有代码。</li>
<li>在大部分用户都不需要的特定情况进行自定义。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123; <span class="comment">// 这里RHS=self 是 default type parameters ，默认的参数，不指定则是它本身</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output; <span class="comment">// rhs 是 right hand side的缩写，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定 RHS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line"></span><br><span class="line">struct Millimeters(u32);</span><br><span class="line">struct Meters(u32);</span><br><span class="line"></span><br><span class="line">impl Add&lt;Meters&gt; for Millimeters &#123; // 指定 和 本身Millimeters不同的Meters</span><br><span class="line">    type Output = Millimeters;</span><br><span class="line"></span><br><span class="line">    fn add(self, other: Meters) -&gt; Millimeters &#123;</span><br><span class="line">        Millimeters(self.0 + (other.0 * 1000))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fully-Qualified-Syntax-for-Disambiguation-Calling-Methods-with-the-Same-Name"><a href="#Fully-Qualified-Syntax-for-Disambiguation-Calling-Methods-with-the-Same-Name" class="headerlink" title="Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name"></a>Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h3><p>如何指定 同名字方法中的一个具体方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>(); <span class="comment">// 如何指定 默认会调用输出  `*waving arms furiously*`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按trait方法</span></span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fully qualified syntax</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 我们希望 puppy</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="title function_ invoke__">baby_name</span>()); <span class="comment">// Spot</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Animal::<span class="title function_ invoke__">baby_name</span>()); <span class="comment">// 没有self 无法推断是哪一个 报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>()); <span class="comment">// puppy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Implementing the <code>OutlinePrint</code> trait that requires the functionality from <code>Display</code></p>
<blockquote>
<p><code>src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会报错 没有实现 std::fmt::Display</span></span><br></pre></td></tr></table></figure>

<p>修复</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types"><a href="#Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types" class="headerlink" title="Using the Newtype Pattern to Implement External Traits on External Types"></a>Using the Newtype Pattern to Implement External Traits on External Types</h3><p>用<code>newtype pattern</code>来摆脱<code>orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate</code>的限制</p>
<p>newtype源于 Haskell</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>)) <span class="comment">// 通过 self.0访问 内部的 Vec&lt;T&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你希望<code>Wrapper</code>有所有inner的method，那么在Wrapper上实现<code>Deref</code>trait</p>
<h2 id="Advanced-Types"><a href="#Advanced-Types" class="headerlink" title="Advanced Types"></a>Advanced Types</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Kilometers</span> = <span class="type">i32</span>; <span class="comment">// 类型别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: Kilometers = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x + y = &#123;&#125;&quot;</span>, x + y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用途2简化书写</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;; <span class="comment">// 类型别名简化书写 不过实际编码中不建议使用Thunk这样的模糊意义明明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: Thunk) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>() <span class="punctuation">-&gt;</span> Thunk &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如<code>std::io</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: fmt::Arguments) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, std::io::Error&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: Arguments) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The Never Type that Never Returns : <code>!</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>continue</code> has a <code>!</code> value.</p>
<p>同样<code>panic!</code>视作返回值也是<code>!</code></p>
<blockquote>
<p>dynamically sized types.</p>
</blockquote>
<p>which <strong>does not</strong> work:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">str</span> = <span class="string">&quot;Hello there!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;How&#x27;s it going?&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们一般用的是<code>&amp;str</code>而不是<code>str</code>,有时也有<code>Box&lt;str&gt;</code>,<code>RC&lt;str&gt;</code></p>
<p>对于trait object</p>
<p><code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code>,<code>Rc&lt;dyn Trait&gt;</code></p>
<p>相对来说&#x2F;&#x2F;之前讲过</p>
<p><code>generic&lt;T&gt;</code>这种 需要在编译时知道大小,也就是以下代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被看做</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来处理</p>
<p>有特殊语法放宽限制</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123; <span class="comment">//T may or may not be Sized ,This syntax is only available for Sized, not any other traits.</span></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Advanced-Functions-and-Closures"><a href="#Advanced-Functions-and-Closures" class="headerlink" title="Advanced Functions and Closures"></a>Advanced Functions and Closures</h2><p>之前闭包<code>Fn</code></p>
<p>函数指针<code>fn</code>:函数指针实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>）</p>
<p>所以可以在要传递闭包时传递函数指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>可以写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>一些结构体 默认有它的初始化函数，也就有默认实现闭包</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>), <span class="comment">// 默认实现了构造函数初始化语法，对应 闭包</span></span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; =</span><br><span class="line">    (<span class="number">0u32</span>..<span class="number">20</span>)</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(Status::Value)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>如何返回闭包</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">// 会报错 没有一个可返回的具体类型</span></span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + &#x27;static:</span><br><span class="line">std::marker::Sized` is not satisfied</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="line">  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + &#x27;static`</span><br><span class="line">  does not have a constant size known at compile-time</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `std::marker::Sized` is not implemented for</span><br><span class="line">  `std::ops::Fn(i32) -&gt; i32 + &#x27;static`</span><br><span class="line">  = note: the return type of a function must have a statical</span><br></pre></td></tr></table></figure>

<p>可行的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h2><p>我们使用过<code>println!</code> </p>
<p>declarative macros with <code>macro_rules!</code></p>
<p>procedural macros:</p>
<ul>
<li>Custom #[derive] macros that specify code added with the derive attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<p>宏可以在编译器翻译代码前展开,Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</p>
<p>简化<code>vec!</code>的定义 &#x2F;&#x2F; The actual definition of the vec! macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.</p>
<p>&#x2F;&#x2F; 看不懂语法 这些 <code>$</code> <code>*</code>是个啥 &#x3D;.&#x3D; 语法<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/macros.html">https://doc.rust-lang.org/reference/macros.html</a></p>
<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123; <span class="comment">// vec![1,2,3]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x); <span class="comment">// 依次等于1,2,3</span></span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#[macro_export]</code> 表明，当这个crate被带入scope，macro变得可用</p>
<p>宏模式所匹配的是 Rust 代码结构而不是值</p>
<blockquote>
<p>Procedural Macros for Generating Code from Attributes</p>
</blockquote>
<p>自定义你的<code>some_attribute</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">some_name</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如 我们自定义一个<code>derive</code> Macro, 目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── hello_macro</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   ├── hello_macro_derive</span><br><span class="line">│   │   ├── Cargo.toml</span><br><span class="line">│   │   └── src</span><br><span class="line">│   │       └── lib.rs</span><br><span class="line">│   └── src</span><br><span class="line">│       └── lib.rs</span><br><span class="line">└── pancakes</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src</span><br><span class="line">        └── main.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pancakes/Cargo.toml</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">hello_macro = &#123; path = <span class="string">&quot;../hello_macro&quot;</span> &#125;</span><br><span class="line">hello_macro_derive = &#123; path = <span class="string">&quot;../hello_macro/hello_macro_derive&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pancakes/src/main.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pancakes</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们希望#[derive(HelloMacro)]宏实现的</span></span><br><span class="line"><span class="comment">impl HelloMacro for Pancakes &#123;</span></span><br><span class="line"><span class="comment">    fn hello_macro() &#123;</span></span><br><span class="line"><span class="comment">        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Pancakes::<span class="title function_ invoke__">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hello_macro/src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HelloMacro</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hello_macro/hello_macro_derive/Cargo.toml</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = true</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">syn = &quot;0.14.4&quot;</span><br><span class="line">quote = &quot;0.6.3&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hello_macro/hello_macro_derive/src/lib.rs</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote; <span class="comment">// quote crate turns syn data structures back into Rust code. </span></span><br><span class="line"><span class="keyword">use</span> syn; <span class="comment">// syn crate 解析Rust 代码 为一个我们可以操作的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有#[derive(HelloMacro)]注解 就会调用下面的proc_macro_derive(HelloMacro)</span></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="comment">// Construct a representation of Rust code as a syntax tree</span></span><br><span class="line">    <span class="comment">// that we can manipulate</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the trait implementation</span></span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说流程:</p>
<ol>
<li>rust编译器检测到<code>derive(XXX)</code>的注解</li>
<li>rust编译器调用对应 <code>proc_macro_derive(XXX)</code>的代码，传入原本的代码</li>
<li>通过syn工具把 字符串代码变成 可以操作的数据结构</li>
<li>在数据结构上提取我们需要的 字段，实现我们希望实现的方法，如上面的<code>impl HelloMacro for #name</code></li>
<li>通过<code>quote!</code>写回宏产生的Rust代码</li>
<li>gen.into()</li>
</ol>
<p>我们最需要关注的就是 我们需要ast的哪些信息，以及我们要生成什么代码，而 提取解析和重新插入代码都一句嗯有现成的库了</p>
<p>最后使用一下</p>
<p><code>cd pancakes &amp;&amp; cargo run</code></p>
<p>正常输出说明我们的宏有作用了</p>
<h3 id="Attribute-like-macros"><a href="#Attribute-like-macros" class="headerlink" title="Attribute-like macros"></a>Attribute-like macros</h3><p>和上面类似</p>
<p>如我们希望实现宏</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;</span><br></pre></td></tr></table></figure>

<p>那么需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>

<p>和上面比较是，上面是通过<code>derive</code> + <code>proc_macro_derive</code>来工作</p>
<p>现在是<code>自定义XXX</code> + <code>proc_macro_attribute</code>+<code>pub fn 自定义XXX</code>来工作</p>
<p>另一个区别是，现在的实现函数接受两个<code>TokenStream</code></p>
<p><code>attr</code>指 如上面<code>GET,&quot;/&quot;</code>这一部分 , 而<code>item</code>指<code>fn index() &#123;</code>等之后的部分</p>
<h3 id="Function-like-macros"><a href="#Function-like-macros" class="headerlink" title="Function-like macros"></a>Function-like macros</h3><p>感觉掌握derive macro的实现以后，后面都很类似了</p>
<p>举例<code>sql!</code></p>
<p>期望使用<code>let sql = sql!(SELECT * FROM posts WHERE id=1);</code></p>
<p>对应实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br></pre></td></tr></table></figure>

<h1 id="Final-Project-Building-a-Multithreaded-Web-Server"><a href="#Final-Project-Building-a-Multithreaded-Web-Server" class="headerlink" title="Final Project: Building a Multithreaded Web Server"></a>Final Project: Building a Multithreaded Web Server</h1><p>终于 终于 final project了,,,,,,</p>
<ul>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ul>
<p>本章仅仅是教学目的，如果真的要搞web server 以及thread pool，请左转<code>https://crates.io/</code></p>
<p>关于 http的知识 就略去了，因为有学过,</p>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">├── 404.html</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── hello.html</span><br><span class="line">└── src</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>src/main.rs</code> 具体业务 和 pool调用</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> hello::ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:7878&quot;</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 监听端口</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123; <span class="comment">// try .take(2) 接受传入的流/网络访问</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream); <span class="comment">// 处理流内容</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123; <span class="comment">// 需要mut 关键字</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>; <span class="comment">// 正常请求</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sleep</span> = <span class="string">b&quot;GET /sleep HTTP/1.1\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(sleep) &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>)); <span class="comment">// 模拟慢请求</span></span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 读取文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status_line, contents); <span class="comment">// 返回给浏览器</span></span><br><span class="line"></span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/lib.rs</code></p>
</blockquote>
<p>作为教学目的实现的ThreadPool</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码的结构</span><br><span class="line">ThreadPool</span><br><span class="line">  Vec&lt; Worker&gt;</span><br><span class="line">      id : worker 在Vec的index，用来标识?</span><br><span class="line">      thread : 每个worker一个线程</span><br><span class="line">          接受到channel的值后 match 结构体是Job还是Terminate</span><br><span class="line">            Job执行方法 封了一个call_box,实际就是调用传递的闭包方法?</span><br><span class="line">      通过lock来</span><br><span class="line">  Sender</span><br><span class="line"></span><br><span class="line">  new():初始化 Workers 和 Sender</span><br><span class="line">  execute():让Sender通过channel发送人物给worker 要执行的闭包给Worker</span><br><span class="line">  </span><br><span class="line">  channel: 结构体 分化为 Job:Box&lt;FnBox + Send + &#x27;static&gt;或Terminate</span><br><span class="line">  drop trait:</span><br><span class="line">      要结束ThreadPool时，让sender发送workersize次 Terminate</span><br><span class="line">      通过 worker.thread.take() + .join()拿去并等待线程结束</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PoolCreationError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">PoolCreationError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Thread pool creation failed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">PoolCreationError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;Thread pool creation failed!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;error::Error&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Message&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">NewJob</span>(Job),</span><br><span class="line">    Terminate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new ThreadPool.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The size is the number of threads in the pool.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ThreadPool, PoolCreationError&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(PoolCreationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver))); <span class="comment">// 启动多个worker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">            F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(Message::<span class="title function_ invoke__">NewJob</span>(job)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sending terminate message to all workers.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(Message::Terminate).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Shutting down all workers.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Shutting down worker &#123;&#125;&quot;</span>, worker.id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(thread) = worker.thread.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;F&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">message</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">match</span> message &#123;</span><br><span class="line">                    Message::<span class="title function_ invoke__">NewJob</span>(job) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing.&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">                        job.<span class="title function_ invoke__">call_box</span>();</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    Message::Terminate =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; was told to terminate.&quot;</span>, id);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread: <span class="title function_ invoke__">Some</span>(thread),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是两个静态html</p>
<blockquote>
<p><code>404.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Oops!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sorry, I don&#x27;t know what you&#x27;re asking for.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hello.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi from Rust<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后<code>cargo run</code>然后用浏览器，或者<code>curl</code>&#x2F;<code>wget</code>就可以尝试访问了</p>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p>附录就不弄过来了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/appendix-00.html">https://doc.rust-lang.org/book/appendix-00.html</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a></p>
<p>最后一章说but we’ve reached the end of the book,好吧 我最开始就想看个tutorial，最后看了一個book</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>重新整理这篇文章,把该加 <code>代码标签</code>的加上<code>代码标签</code></p>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>作者： </strong>Cro-Marmot
  </li>
  <li class="post-copyright-link">
      <strong>文章連結：</strong>
      <a href="https://cromarmot.github.io/Blog/19-08-15-rust/" title="rust book 学习笔记">https://cromarmot.github.io/Blog/19-08-15-rust/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 許可協議。轉載請註明出處！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/Blog/tags/rust/" rel="tag"><i class="fa fa-tag"></i> rust</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Blog/19-07-26-jenkins/" rel="prev" title="jenkins 入门尝试">
                  <i class="fa fa-chevron-left"></i> jenkins 入门尝试
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Blog/19-08-21-the-black-swan/" rel="next" title="黑天鹅：如何应对不可预知的未来 阅读笔记">
                  黑天鹅：如何应对不可预知的未来 阅读笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cro-Marmot</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="總字數">645k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="所需總閱讀時間">9:47</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/Blog/js/comments.js"></script><script src="/Blog/js/utils.js"></script><script src="/Blog/js/motion.js"></script><script src="/Blog/js/schemes/muse.js"></script><script src="/Blog/js/next-boot.js"></script><script src="/Blog/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/Blog/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/Blog/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.2.0/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://cromarmot.github.io/Blog/19-08-15-rust/"}</script>
  <script src="/Blog/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"cromarmot","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/Blog/js/third-party/comments/disqus.js"></script>

</body>
</html>
